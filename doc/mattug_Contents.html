<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,IE=9,chrome=1"><meta name="generator" content="MATLAB R2020a"><title>MatTuGames: A Matlab Game Theory Toolbox </title><style type="text/css">.rtcContent { padding: 30px; } .S0 { margin: 3px 10px 5px 4px; padding: 0px; line-height: 28.8px; min-height: 0px; white-space: pre-wrap; color: rgb(213, 80, 0); font-family: Helvetica, Arial, sans-serif; font-style: normal; font-size: 24px; font-weight: normal; text-align: left;  }
.S1 { margin: 2px 10px 9px 4px; padding: 0px; line-height: 21px; min-height: 0px; white-space: pre-wrap; color: rgb(0, 0, 0); font-family: Helvetica, Arial, sans-serif; font-style: normal; font-size: 14px; font-weight: normal; text-align: left;  }
.S2 { margin: 20px 10px 5px 4px; padding: 0px; line-height: 20px; min-height: 0px; white-space: pre-wrap; color: rgb(60, 60, 60); font-family: Helvetica, Arial, sans-serif; font-style: normal; font-size: 20px; font-weight: bold; text-align: left;  }
.S3 { margin: 15px 10px 5px 4px; padding: 0px; line-height: 18px; min-height: 0px; white-space: pre-wrap; color: rgb(60, 60, 60); font-family: Helvetica, Arial, sans-serif; font-style: normal; font-size: 17px; font-weight: bold; text-align: left;  }</style></head><body><div class = rtcContent><h1  class = 'S0'><span>MatTuGames: A Matlab Game Theory Toolbox </span></h1><div  class = 'S1'><span>Version 1.8 (R2019b) 31-Jan-2020</span></div><div  class = 'S1'><span>Author:        Holger I. Meinhardt </span></div><div  class = 'S1'><span>E-Mail:        Holger.Meinhardt@wiwi.uni-karlsruhe.de</span></div><div  class = 'S1'><span>Institution:   University of Karlsruhe (KIT)</span></div><div  class = 'S1'><span></span></div><h2  class = 'S2'><span>Some Auxiliary Files</span></h2><div  class = 'S1'><span></span></div><div  class = 'S1'><span>FrameToImage                              - Converts a frame to an image.</span></div><div  class = 'S1'><span>PlayCoreMovie                             - Plays a movie from a collection of frames.</span></div><div  class = 'S1'><span>ginv                                              - Computes a general inverse.</span></div><div  class = 'S1'><span>myaa                                            - MYAA Render figure with anti-aliasing.</span></div><div  class = 'S1'><span>qrginv                                           - Computes a pseudo-inverse using a QR-method.</span></div><div  class = 'S1'><span>vtk_export                                    - Exportes the graphical raw data to VTK legacy format.</span></div><div  class = 'S1'><span></span></div><div  class = 'S1'><span></span></div><h2  class = 'S2'><span>Scirpt File</span></h2><div  class = 'S1'><span></span></div><div  class = 'S1'><span>corevert                                      - External bash script to call the cdd library. </span></div><div  class = 'S1'><span>                                                              </span></div><h2  class = 'S2'><span>Document Files                    </span></h2><div  class = 'S1'><span>       </span></div><div  class = 'S1'><span>MatTuGames_Version_1.8.m                  - Additions and changes in version 1.8</span></div><div  class = 'S1'><span>ReadMe.pdf                                             - Installation instruction (PDF)</span></div><div  class = 'S1'><span>ReadMe.md                                             - Installation instruction (Markdown Format)</span></div><div  class = 'S1'><span>getting_started.m                                    - Checks the installation</span></div><div  class = 'S1'><span>getting_started.out                                  - Reference results of getting_started</span></div><div  class = 'S1'><span>getting_started.md                                   - Reference results of getting_started (Markdown Format)   </span></div><div  class = 'S1'><span>manual_mat_tugames.pdf                        - Manual (PDF)</span></div><div  class = 'S1'><span>MatTuGames_References.md                 - Bibliography (Markdown Format)</span></div><div  class = 'S1'><span>MatTuGames_References.pdf                - Bibliography (PDF)    </span></div><div  class = 'S1'><span>testcase_graphics                                    - Checking basic graphic installation.</span></div><div  class = 'S1'><span></span></div><h2  class = 'S2'><span>Graphic Example Files</span></h2><div  class = 'S1'><span></span></div><div  class = 'S1'><span>core_exp.pdf                                   - Core plot example 3d.</span></div><div  class = 'S1'><span>core_exp_all.pdf                             - Core plot example 3d.</span></div><div  class = 'S1'><span>core_exp_prk.pdf                            - Core plot example 3d.</span></div><div  class = 'S1'><span>core_exp_prn.pdf                            - Core plot example 3d.</span></div><div  class = 'S1'><span>core_exp_shap.pdf                         - Core plot example 3d.</span></div><div  class = 'S1'><span>core_exp_sol_all.pdf                       - Core plot example 3d.</span></div><div  class = 'S1'><span>core_exp_sol_none.pdf                   - Core plot example 3d.</span></div><div  class = 'S1'><span>core_exp_sol_prk.pdf                      - Core plot example 3d.</span></div><div  class = 'S1'><span>core_exp_sol_prn.pdf                     - Core plot example 3d.</span></div><div  class = 'S1'><span>core_exp_sol_shap.pdf                   - Core plot example 3d.</span></div><div  class = 'S1'><span>manual_exp2_core01.p                  - Core plot example 3d.</span></div><div  class = 'S1'><span></span></div><h2  class = 'S2'><span>Mathematica Symbolic Toolbox Functions to call the Mathematica Package TuGames</span></h2><div  class = 'S1'><span></span></div><div  class = 'S1'><span>tug_AdjustedWorthVectors                  - Computes the adjusted worth vectors of k-convex games.   </span></div><div  class = 'S1'><span>tug_AllAntiSurpluses                      - Computes the minimum surpluses.</span></div><div  class = 'S1'><span>tug_AllMaxSurpluses                       - Computes the maximum surpluses.</span></div><div  class = 'S1'><span>tug_AntiPreKernel                         - Computes an anti-pre-kernel point.</span></div><div  class = 'S1'><span>tug_AntiPreKernelQ                        - Checks if an imputation is an anti-pre-kernel point.</span></div><div  class = 'S1'><span>tug_AvConvexQ                             - Checks on average convexity.</span></div><div  class = 'S1'><span>tug_AverageConvexQ                        - Checks on average convexity.</span></div><div  class = 'S1'><span>tug_BalancedKSelectionQ                   - Checks if an imputation induces a k-balanced selection.</span></div><div  class = 'S1'><span>tug_BalancedSelectionQ                    - Checks if an imputation induces a balanced selection.</span></div><div  class = 'S1'><span>tug_Bankruptcy                            - Creates a modest bankruptcy game.</span></div><div  class = 'S1'><span>tug_BelongToCoreQ                         - Checks if an imputation belongs to the core.</span></div><div  class = 'S1'><span>tug_BestCoalToMatrix                      - Computes an equivalence matrix. </span></div><div  class = 'S1'><span>tug_Bsc                                   - Returns the set of most effective coalitions.</span></div><div  class = 'S1'><span>tug_CharacteristicValues                  - Computes the characteristic values.</span></div><div  class = 'S1'><span>tug_Coal2Dec                              - List of proper coalitions in Mathematica order.</span></div><div  class = 'S1'><span>tug_CollectionBalancedQ                   - Checks if a collection is balanced.</span></div><div  class = 'S1'><span>tug_CollectionOfDecreasingExcess          - Creates the collection of decreasing excesses.</span></div><div  class = 'S1'><span>tug_Concession                            - Computes the concession vector.</span></div><div  class = 'S1'><span>tug_ContestedGarment                      - Computes the contested garment. </span></div><div  class = 'S1'><span>tug_ConvexQ                               - Checks convexity.</span></div><div  class = 'S1'><span>tug_ConvexUnanConditionQ                  - Checks convexity while relying on the unanimity coordinates.</span></div><div  class = 'S1'><span>tug_CoreElementsQ                         - Checks if an imputation belongs to the core.</span></div><div  class = 'S1'><span>tug_CoreQ                                 - Checks if the core is non-empty. </span></div><div  class = 'S1'><span>tug_CostSavings                           - Creates the cost savings game.</span></div><div  class = 'S1'><span>tug_CriticalVal                           - Computes some critical epsilon values.</span></div><div  class = 'S1'><span>tug_DetQuasiAvConvex                      - Determines a quasi average convex game.</span></div><div  class = 'S1'><span>tug_DetRandCoord                          - Returns random unanimity coordinates.</span></div><div  class = 'S1'><span>tug_DetUCoord                             - Determines the missing unanimity coordinates of size greater than 2. </span></div><div  class = 'S1'><span>tug_Disagreement                          - Computes the disagreement vector.</span></div><div  class = 'S1'><span>tug_DualGame                              - Creates the dual of a Tu-game.</span></div><div  class = 'S1'><span>tug_EpsCore                               - Computes the least core.</span></div><div  class = 'S1'><span>tug_EqClass                               - Determines the equivalence classes from the set of most effective coalitions.</span></div><div  class = 'S1'><span>tug_EvalSumMinCoord                       - Calculates at most (n-1) inequalities of the unanimity coordinates constraints of nonnegative sums.</span></div><div  class = 'S1'><span>tug_ExcessValues                          - Determines the excesses.</span></div><div  class = 'S1'><span>tug_FindPreKernel                         - Computes a pre-kernel element.</span></div><div  class = 'S1'><span>tug_GameMonotoneQ                         - Checks on monotonicity.</span></div><div  class = 'S1'><span>tug_Gap                                   - Computes the gap function.</span></div><div  class = 'S1'><span>tug_GrandCoalitionLargestValueQ           - Checks if the grand coalition has largest value.</span></div><div  class = 'S1'><span>tug_GreedyBankruptcy                      - Creates the greedy bankruptcy game.</span></div><div  class = 'S1'><span>tug_HarsanyiDividends                     - Creates the unanimity coordinates.</span></div><div  class = 'S1'><span>tug_ImpToVec                              - Converts an imputation to a set of vectors.</span></div><div  class = 'S1'><span>tug_ImputationQ                           - Checks if a payoff vector is an imputation.</span></div><div  class = 'S1'><span>tug_IntersectionOfMaxExcessSets           - Determines if the set of proper coalitions having largest excesses has an empty intersection.</span></div><div  class = 'S1'><span>tug_IntersectionUpperLowerSetQ            - Checks if the intersection of the lower and upper set is non-empty. </span></div><div  class = 'S1'><span>tug_Kernel                                - Computes a kernel point.</span></div><div  class = 'S1'><span>tug_KernelCalculation                     - Computes a or some kernel element(s).</span></div><div  class = 'S1'><span>tug_KernelImputationQ                     - Checks if an imputation is a kernel point.</span></div><div  class = 'S1'><span>tug_KernelVertices                        - Computes a kernel segment.</span></div><div  class = 'S1'><span>tug_LargestAmount                         - Computes the largest amount.</span></div><div  class = 'S1'><span>tug_LeastCore                             - Determine the least core.</span></div><div  class = 'S1'><span>tug_LexiCenter                            - Computes the lexi center.</span></div><div  class = 'S1'><span>tug_LowerSetIncImputationQ                - Checks if the lower set is included in the imputation set.</span></div><div  class = 'S1'><span>tug_LowerSetQ                             - Checks if an imputation belongs to the lower set.</span></div><div  class = 'S1'><span>tug_MKernel                               - Determines a kernel point.</span></div><div  class = 'S1'><span>tug_MLExtension                           - Computes the multi-linear extension.</span></div><div  class = 'S1'><span>tug_MargValue                             - Determines the marginal contribution vector.</span></div><div  class = 'S1'><span>tug_MaxExcessBalanced                     - Checks if the maximum surpluses are balanced.</span></div><div  class = 'S1'><span>tug_MaxExcessSets                         - Computes the set of proper coalitions having largest excesses.</span></div><div  class = 'S1'><span>tug_MinExcessBalanced                     - Determines if the minimum surpluses are balanced.</span></div><div  class = 'S1'><span>tug_MinUnanimityCoordinates               - Returns the minimum unanimity coordinates. </span></div><div  class = 'S1'><span>tug_Mnuc                                  - Determines the nucleolus.</span></div><div  class = 'S1'><span>tug_MonotoneQ                             - Checks on monotonicity.</span></div><div  class = 'S1'><span>tug_Nuc                                   - Computes the nucleolus.</span></div><div  class = 'S1'><span>tug_OneNormalization                      - Creates a one normalized game.</span></div><div  class = 'S1'><span>tug_PreKernel                             - Computes a pre-kernel element.</span></div><div  class = 'S1'><span>tug_PreKernelEl                           - Computes a pre-kernel element.</span></div><div  class = 'S1'><span>tug_PreKernelEqualsKernelQ                - Checks if the pre-kernel coincides with the kernel.</span></div><div  class = 'S1'><span>tug_PreKernelQ                            - Checks if an imputation is a pre-kernel element.</span></div><div  class = 'S1'><span>tug_PreNuc                                - Computes the pre-nucleolus.</span></div><div  class = 'S1'><span>tug_ProperAmount                          - Computes the proper amount.</span></div><div  class = 'S1'><span>tug_Quota                                 - Computes the quotas.</span></div><div  class = 'S1'><span>tug_ReasonableOutcome                     - Computes the reasonable outcome.</span></div><div  class = 'S1'><span>tug_ReasonableSet                         - Computes the reasonable set.</span></div><div  class = 'S1'><span>tug_ScrbSolution                          - Determines the Scrb solution.</span></div><div  class = 'S1'><span>tug_SetsToVec                             - Converts the set of most effective coalitions to a set of vectors.</span></div><div  class = 'S1'><span>tug_ShapleyValue                          - Determines the Shapley value.</span></div><div  class = 'S1'><span>tug_ShapleyValueML                        - Determines the Shapley value using multi-linear extension.</span></div><div  class = 'S1'><span>tug_SmallestContribution                  - Determines the smallest contribution vector.</span></div><div  class = 'S1'><span>tug_StrictlyConvexUnanConditionQ          - Examines the sufficient condition of convexity in terms of unanimity coordinates.</span></div><div  class = 'S1'><span>tug_SuperAdditiveQ                        - Checks on super-additivity.</span></div><div  class = 'S1'><span>tug_SymGameSizeK                          - Returns a special type of symmetric game.</span></div><div  class = 'S1'><span>tug_SymGameType2                          - Returns a special type of symmetric game.</span></div><div  class = 'S1'><span>tug_SymGameType3                          - Returns a special type of symmetric game.</span></div><div  class = 'S1'><span>tug_SymGameType4                          - Returns a special type of symmetric game.</span></div><div  class = 'S1'><span>tug_TalmudicRule                          - Computes the Talmudic distribution rule.</span></div><div  class = 'S1'><span>tug_TauValue                              - Determines the Tau value.</span></div><div  class = 'S1'><span>tug_UnanAvConvexQ                         - Checks if the coordinates satisfy the sufficient and necessary condition of average convexity.</span></div><div  class = 'S1'><span>tug_UnanConvexQ                           - Checks if the coordinates satisfy the sufficient and necessary condition of convexity.</span></div><div  class = 'S1'><span>tug_UnanimityCoordinates                  - Determines all unanimity coordinates of the game</span></div><div  class = 'S1'><span>tug_UpperSetIncImputationQ                - Checks if the upper set is included in the imputation set.</span></div><div  class = 'S1'><span>tug_UpperSetQ                             - Checks if an imputation belongs to the upper set.</span></div><div  class = 'S1'><span>tug_UtopiaVector                          - Computes the utopia payoff. </span></div><div  class = 'S1'><span>tug_ValueExcess                           - Computes an objective function to compute a pre-kernel element.</span></div><div  class = 'S1'><span>tug_VerticesCore                          - Determines the vertices of the core.</span></div><div  class = 'S1'><span>tug_WeaklySuperAdditiveQ                  - Checks if the Tu-game is weakly super-additive.</span></div><div  class = 'S1'><span>tug_WeightedMajority                      - Creates the weighted majority game.</span></div><div  class = 'S1'><span>tug_ZeroMonotoneQ                         - Checks on zero-monotonicity.</span></div><div  class = 'S1'><span>tug_ZeroNormalization                     - Creates the zero normalized game.</span></div><div  class = 'S1'><span>tug_ZeroOneNormalization                  - Creates the zero-one normalized game.</span></div><div  class = 'S1'><span>tug_kCover                                - Determines from the Tu-game the corresponding k-game.</span></div><div  class = 'S1'><span></span></div><h2  class = 'S2'><span>Main Functions: Serial Computing</span></h2><div  class = 'S1'><span></span></div><div  class = 'S1'><span>ADvalue                                   - Computes the Aumann-Dreze value.</span></div><div  class = 'S1'><span>AdditiveQ                                 - Checks if the game v is additive.</span></div><div  class = 'S1'><span>AllMarginalContributions                  - Computes all marginal contributions of a Tu game.</span></div><div  class = 'S1'><span>AllSubGames                               - Computes all subgames.</span></div><div  class = 'S1'><span>AntiCoreCoverQ                            - Checks if the anti-core cover is non-empty.</span></div><div  class = 'S1'><span>AntiCorePlot                              - Plots the anti-core.</span></div><div  class = 'S1'><span>AntiCoreVertices                          - Evaluates the vertices of the anti-core.</span></div><div  class = 'S1'><span>AntiImputationVertices                    - Computes all vertices of the anti imputation set.</span></div><div  class = 'S1'><span>AntiReduced_game_propertyQ  		    - Checks whether an imputation x satisfies the anti-reduced game property. </span></div><div  class = 'S1'><span>AntiUtopiaPayoff                          - Computes the anti-utopia and agreement vector.</span></div><div  class = 'S1'><span>Anti_B0_balancedCollectionQ               - Checks the reversal of weak Kohlberg's criterion.</span></div><div  class = 'S1'><span>Anti_BestCoalitions  			    - Computes the set of less effective coalitions.</span></div><div  class = 'S1'><span>Anti_Converse_DGP_Q  			    - Checks whether an imputation x satisfies the anti-converse derived game property.</span></div><div  class = 'S1'><span>Anti_DerivedGame  			    - Computes from (v,x,S) a modified Davis-Maschler anti-derived game vS on S at x for game v.</span></div><div  class = 'S1'><span>Anti_Derived_game_propertyQ  		    - Checks whether an imputation x satisfies a modified anti-derived game property.</span></div><div  class = 'S1'><span>Anti_Kernel                               - Computes an anti-kernel point.</span></div><div  class = 'S1'><span>Anti_ModPreKernel  			    - Computes from (v,x) an anti-modified pre-kernel element.</span></div><div  class = 'S1'><span>Anti_ModPrekernelQ  			    - Checks whether the imputation x is a modified anti-pre-kernel element of the TU-game v.</span></div><div  class = 'S1'><span>Anti_Nucl                                 - Computes the anti nucleolus of a game.</span></div><div  class = 'S1'><span>Anti_Nucl_llp                             - Computes the anti nucleolus of a game.</span></div><div  class = 'S1'><span>Anti_PModPreKernel  			    - Computes from (v,x) an anti-proper-modified pre-kernel element.</span></div><div  class = 'S1'><span>Anti_PModPrekernelQ  			    - Checks whether the imputation x is a proper modified anti-pre-kernel element of the TU-game v.</span></div><div  class = 'S1'><span>Anti_PreKernel                            - Computes an anti-prekernel point.</span></div><div  class = 'S1'><span>Anti_PreNucl                              - Computes the anti pre-nucleolus of game v.</span></div><div  class = 'S1'><span>Anti_PreNucl_llp                          - Computes the anti pre-nucleolus of game v.</span></div><div  class = 'S1'><span>Anti_PrekernelQ                           - Checks if an imputation is an anti prekernel point.</span></div><div  class = 'S1'><span>Anti_PropModPreKernel  		    - Checks whether the imputation x is a proper modified anti-pre-kernel element of the TU-game v.	    </span></div><div  class = 'S1'><span>Anti_balancedCollectionQ                  - Checks the reversal of Kohlberg's criterion.</span></div><div  class = 'S1'><span>Anti_kernelQ                              - Checks if an imputation is an anti kernel point.</span></div><div  class = 'S1'><span>B0_balancedCollectionQ                    - Checking weak Kohlberg's criterion.</span></div><div  class = 'S1'><span>B0_balancedQ                              - Verifies whether the collection of coalitions is weakly balanced.</span></div><div  class = 'S1'><span>BestCoalitions                            - Computes the set of most effective coalitions.</span></div><div  class = 'S1'><span>COV_propertyQ                             - Verifies if the payoff x satisfies COV property.</span></div><div  class = 'S1'><span>CddAntiCoreCoverPlot                      - Plots the anti-core cover set.</span></div><div  class = 'S1'><span>CddAntiCoreCoverVertices                  - Computes all vertices of the anti-core cover set.</span></div><div  class = 'S1'><span>CddAntiCorePlot                           - Plots the anti-core of a game using cddmex. </span></div><div  class = 'S1'><span>CddAntiCoreQ                              - Checks if the anti-core exists (cddmex).</span></div><div  class = 'S1'><span>CddAntiCoreSimplexPlot                    - Plots the anti-core using simplex projection.</span></div><div  class = 'S1'><span>CddAntiCoreSimplexVertices                - Computes all anti-core vertices using simplex projection.</span></div><div  class = 'S1'><span>CddAntiCoreVertices                       - Computes the vertices of the anti-core (cddmex).</span></div><div  class = 'S1'><span>CddAntiImputationSimplexVertices          - Computes all vertices of the anti-imputation set using simplex projection.</span></div><div  class = 'S1'><span>CddAntiImputationVertices                 - Computes all vertices of the anti-imputation set.</span></div><div  class = 'S1'><span>CddAntiLeastCore                          - Computes the least core of game v using (cddmex).</span></div><div  class = 'S1'><span>CddAntiLeastCoreVertices                  - Computes the vertices of the anti least core of game v (cddmex).</span></div><div  class = 'S1'><span>CddAntiNucl                               - Computes the anti nucleolus of game v (cddmex).</span></div><div  class = 'S1'><span>CddAntiNucl_llp                           - Computes the anti nucleolus of game v (cddmex).</span></div><div  class = 'S1'><span>CddAntiPrenucl                            - Computes the anti pre-nucleolus of game v (cddmex).</span></div><div  class = 'S1'><span>CddAntiPrenucl_llp                        - Computes the anti pre-nucleolus of game v (cddmex).</span></div><div  class = 'S1'><span>CddBelongToLeastCoreQ                     - Checks if a payoff vector belongs to the least-core.</span></div><div  class = 'S1'><span>CddCoreCoverPlot                          - Plots the core cover of a TU game.</span></div><div  class = 'S1'><span>CddCoreCoverSimplexPlot                   - Plots the core cover (simplex projection).</span></div><div  class = 'S1'><span>CddCoreCoverSimplexVertices               - Computes all vertices of the core cover (simplex).</span></div><div  class = 'S1'><span>CddCoreCoverVertices                      - Computes all vertices of the core cover of a TU game.</span></div><div  class = 'S1'><span>CddCoreMovie                              - Creates a movie w.r.t. the strong epsilon-cores.</span></div><div  class = 'S1'><span>CddCorePlot                               - Plots the core of a game using cddmex. </span></div><div  class = 'S1'><span>CddCoreQ                                  - Checks if the core exists (cddmex).</span></div><div  class = 'S1'><span>CddCoreSimplexMovie                       - Creates a movie w.r.t. the strong epsilon-cores (simplex projection).</span></div><div  class = 'S1'><span>CddCoreSimplexPlot                        - Plots the core (simplex projection).</span></div><div  class = 'S1'><span>CddCoreSimplexVertices                    - Computes the vertices of the core (simplex).</span></div><div  class = 'S1'><span>CddCoreVertices                           - Computes the vertices of the core (cddmex).</span></div><div  class = 'S1'><span>CddExactGame                              - Computes the exact game from v (cddmex).</span></div><div  class = 'S1'><span>CddImputationSimplexVertices              - Computes the vertices of the imputation set (simplex).</span></div><div  class = 'S1'><span>CddImputationVertices                     - Computes the vertices of the imputation set (cddmex).</span></div><div  class = 'S1'><span>CddKernelCatchers                         - Draws some kernel catchers (cddmex).</span></div><div  class = 'S1'><span>CddKernelCatchersSimplex                  - Draws some kernel catchers (simplex).</span></div><div  class = 'S1'><span>CddLeastCore                              - Computes the leastcore (cddmex).</span></div><div  class = 'S1'><span>CddLeastCoreVertices                      - Computes the leastcore vertices (cddmex). </span></div><div  class = 'S1'><span>CddLowerSetSimplexVertices                - Computes the vertices of the lower set (simplex). </span></div><div  class = 'S1'><span>CddLowerSetVertices                       - Computes the vertices of the lower set (cddmex). </span></div><div  class = 'S1'><span>CddModiclus                               - Computes the modiclus of game v using cddmex.</span></div><div  class = 'S1'><span>CddNucl                                   - Computes the nucleolus using the CDD solver (cddmex).</span></div><div  class = 'S1'><span>CddNucl_llp                               - Computes the nucleolus using the CDD solver (cddmex).</span></div><div  class = 'S1'><span>CddPreKernel                              - Computes a pre-kernel element (cddmex).</span></div><div  class = 'S1'><span>CddPrenucl                                - Computes the prenucleolus using the CDD solver (cddmex).</span></div><div  class = 'S1'><span>CddPrenucl_llp                            - Computes the prenucleolus using the CDD solver (cddmex).</span></div><div  class = 'S1'><span>CddReasonableSetSimplexVertices           - Computes the vertices of the reasonable set (simplex). </span></div><div  class = 'S1'><span>CddReasonableSetVertices                  - Computes the vertices of the reasonable set (cddmex). </span></div><div  class = 'S1'><span>CddStrongCorePlot                         - Plots a strong epsilon core. </span></div><div  class = 'S1'><span>CddStrongCoreSimplexPlot                  - Plots the strong epsilon core (simplex projection).</span></div><div  class = 'S1'><span>CddTotallyBalancedQ  			    - Checks whether the core of all subgames is non-empty (cddmex).</span></div><div  class = 'S1'><span>CddUpperSetSimplexVertices                - Computes the vertices of the upper set (simplex). </span></div><div  class = 'S1'><span>CddUpperSetVertices                       - Computes the vertices of the upper set (cddmex). </span></div><div  class = 'S1'><span>CddWeberSet                               - Computes the vertices of the Weber Set.</span></div><div  class = 'S1'><span>CddWeberSetPlot                           - Plots the Weber set.</span></div><div  class = 'S1'><span>CddWeberSetSimplex                        - Computes the vertices of the Weber Set (simplex).</span></div><div  class = 'S1'><span>CddWeberSetSimplexPlot                    - Plots the Weber set (simplex).</span></div><div  class = 'S1'><span>CoalitionSolidarity                       - Determines the coalition solidarity value.</span></div><div  class = 'S1'><span>ConstantSumQ                              - Checks if the game v has constant-sum.</span></div><div  class = 'S1'><span>Converse_DGP_Q  			    - Checks whether an imputation x satisfies the converse derived game property.</span></div><div  class = 'S1'><span>Converse_RGP_Q                            - Checks if an imputation satisfies the CRGP.</span></div><div  class = 'S1'><span>CoreCoverQ                                - Checks if the core cover a TU game v is non-empty.</span></div><div  class = 'S1'><span>CorePlot                                  - Plots the core.</span></div><div  class = 'S1'><span>CoreVertices                              - Computes the vertices of the core.</span></div><div  class = 'S1'><span>DCP_propertyQ  			    - Checks whether the solution x satisfies the dual cover property.	    </span></div><div  class = 'S1'><span>DFP_propertyQ  			    - Checks whether the solution x satisfies the dual floor property.	    </span></div><div  class = 'S1'><span>DM_AntiReduced_game  			    - Computes from (v,x) all anti-reduced games on S at x of game v.</span></div><div  class = 'S1'><span>DM_Anti_Derived_game  		    - Computes from (v,x) a modified Davis-Maschler anti-reduced game vS on S at x for game v.</span></div><div  class = 'S1'><span>DM_Derived_game  			    - Computes from (v,x) a modified Davis-Maschler reduced game vS on S at x for game v.</span></div><div  class = 'S1'><span>DM_Reduced_game                           - Computes all Davis-Maschler reduced games.</span></div><div  class = 'S1'><span>DM_TwoPersonGame                          - Computes from (v,x) all reduced two-person games.</span></div><div  class = 'S1'><span>DM_TwoReduced_game  			    - Computes from (v,x) all single and two-person reduced games on S at x of game v.</span></div><div  class = 'S1'><span>DRP_propertyQ  			    - Checks whether the solution x satisfies the dual replication property.	    </span></div><div  class = 'S1'><span>DecomposeGame                             - Computes the unique decomposition of a TU-game.</span></div><div  class = 'S1'><span>DerivedGame  				    - Computes from (v,x,S) a modified Davis-Maschler derived game vS on S at x for game v.</span></div><div  class = 'S1'><span>Derived_game_propertyQ  		    - Checks whether an imputation x satisfies a modified derived game property.</span></div><div  class = 'S1'><span>DiscShapleyValue                          - Computes the discounted Shapley value.</span></div><div  class = 'S1'><span>DualCover  				    - Computes the maximum characteristic values from the primal or dual game.</span></div><div  class = 'S1'><span>DualFloor  				    - Computes the minimum characteristic values from the primal or dual game.</span></div><div  class = 'S1'><span>Dual_Floor_game  			    - Computes from (v,x) a modified Davis-Maschler the anti reduced game vS on S at x for game v.</span></div><div  class = 'S1'><span>Dual_Floor_propertyQ  		    - Checks whether an imputation x satisfies a modified anti reduced game property	    </span></div><div  class = 'S1'><span>Dual_Cover_game  			    - Computes from (v,x) a modified Davis-Maschler reduced game vS on S at x for game v.</span></div><div  class = 'S1'><span>Dual_Cover_propertyQ  		    - Checks whether an imputation x satisfies a modified reduced game property	    </span></div><div  class = 'S1'><span>DuttaRay  				    - Computes the Dutta-Ray solution for convex games.</span></div><div  class = 'S1'><span>ECCoverGame  				    - Computes from (v,x) an excess comparability cover of game v.</span></div><div  class = 'S1'><span>ECFloorGame  				    - Computes from (v,x) an excess comparability floor of game v.</span></div><div  class = 'S1'><span>EC_DGP_Q  				    - Checks whether the solution x satisfies excess comparability for each derived game.</span></div><div  class = 'S1'><span>EC_RGP_Q  				    - Checks whether the solution x satisfies excess comparability for each reduced game.</span></div><div  class = 'S1'><span>EC_propertyQ  			    - Checks whether the solution x satisfies excess comparability.	    </span></div><div  class = 'S1'><span>ESD                                       - Computes the equal surplus division of a TU-game.</span></div><div  class = 'S1'><span>EssentialQ                                - Checks if the game v is essential.</span></div><div  class = 'S1'><span>FlatQ                                     - Checks if the game v is flat.</span></div><div  class = 'S1'><span>Gap                                       - Determines the gap function.</span></div><div  class = 'S1'><span>HMS_AntiReduced_game  		    - Computes from (v,x) all Hart/Mas-Colell anti-reduced games on S at x of game v.	    </span></div><div  class = 'S1'><span>HMS_Anti_Derived_game  		    - Computes from (v,x,S) a modified Hart-Mas-Colell anti-reduced game vS on S at x for game v.	    </span></div><div  class = 'S1'><span>HMS_Derived_game  			    - Computes from (v,x,S) a modified Hart-Mas-Colell reduced game vS on S at x for game v.</span></div><div  class = 'S1'><span>HMS_DervGame  			    - Computes from (v,x,S) a modified Hart-Mas-Colell derived game vS on S at x for game v.	    </span></div><div  class = 'S1'><span>HMS_ImputSavingReducedGame                - Computes from (v,x) all Hart/Mas-Colell ISR games.</span></div><div  class = 'S1'><span>HMS_RedGame  				    - Computes from (v,x,S) a Hart-MasColell reduced game vS on S at x for game v.</span></div><div  class = 'S1'><span>HMS_Reduced_game                          - Creates all Hart/Mas-Colell reduced games. </span></div><div  class = 'S1'><span>HMS_TwoReduced_game  			    - Computes from (v,x) all Hart/Mas-Colell singleton and two-person reduced games on S at x of game v.</span></div><div  class = 'S1'><span>ISRG_propertyQ                            - Checks whether an imputation x satisfies the ISR game property.</span></div><div  class = 'S1'><span>ImpSetEqsLwsQ                             - Checks if the imputation set coincides with the lower set.</span></div><div  class = 'S1'><span>ImputSavingReducedGame                    - Computes from (v,x) all imputation saving reduced games.</span></div><div  class = 'S1'><span>ImputationVertices                        - Computes the vertices of the imputation set.</span></div><div  class = 'S1'><span>InteractionSets                           - Determines a system of interaction sets.</span></div><div  class = 'S1'><span>Kernel                                    - Computes a kernel point using optimization toolbox.</span></div><div  class = 'S1'><span>KrEqsPrkQ                                 - Checks if the kernel is equal to the pre-kernel.</span></div><div  class = 'S1'><span>LED  					    - Computes the large excess difference w.r.t. the payoff x.	    </span></div><div  class = 'S1'><span>LED_propertyQ  			    - Checks whether the solution x satisfies large excess difference property.	    </span></div><div  class = 'S1'><span>LS_Nucl                                   - Computes the least square nucleolus of a game.</span></div><div  class = 'S1'><span>LS_PreNucl                                - Computes the least square pre-nucleolus of a game.</span></div><div  class = 'S1'><span>LeastCore                                 - Computes the leastcore using optimization toolbox.</span></div><div  class = 'S1'><span>LeastCoreVertices                         - Computes the leastcore vertices. </span></div><div  class = 'S1'><span>LedcoconsQ  				    - Checks whether an imputation x satisfies large excess difference converse consistency.</span></div><div  class = 'S1'><span>Ledcons_propertyQ  			    - Checks whether an imputation x satisfies the ledcons property </span></div><div  class = 'S1'><span>LorenzDom                                 - Checks if x Lorenz dominates y in game v.</span></div><div  class = 'S1'><span>LorenzSet                                 - Determines the Lorenz set of game v.</span></div><div  class = 'S1'><span>LorenzSol  				    - Determines the Lorenz solution of game v.</span></div><div  class = 'S1'><span>MLextension                               - Computes the multi-linear extension.</span></div><div  class = 'S1'><span>MMExcess  				    - Computes the minimal and maximal excess vector of game v and its dual.</span></div><div  class = 'S1'><span>ModHoller  				    - Computes a modified Holler index from the set of winning coalitions.</span></div><div  class = 'S1'><span>ModPreKernel  			    - Computes from (v,x) a modified pre-kernel element.	    </span></div><div  class = 'S1'><span>ModPrekernelQ  			    - Checks whether the imputation x is a modified pre-kernel element of the TU-game v.	    </span></div><div  class = 'S1'><span>Modiclus                                  - Computes the modiclus of a game.</span></div><div  class = 'S1'><span>MyersonValue                              - Computes the Myerson value of a Tu game.</span></div><div  class = 'S1'><span>NullPlayer_propertyQ                      - Verifies if x satisfies the null player property.</span></div><div  class = 'S1'><span>One_Normalization                         - Computes from the game v the corresponding one-normalized game.</span></div><div  class = 'S1'><span>OwenValue                                 - Computes the Owen value.</span></div><div  class = 'S1'><span>PModPreKernel  			    - Computes from (v,x) a proper modified pre-kernel element.	    </span></div><div  class = 'S1'><span>PModPrekernelQ  			    - Checks whether the imputation x is a proper modified pre-kernel element of the TU-game v.</span></div><div  class = 'S1'><span>PRP_propertyQ  			    - Checks whether the solution x satisfies the primal replication property.	    </span></div><div  class = 'S1'><span>PartitionSA                               - Computes a partition of S w.r.t. a hypergraph communication situation.</span></div><div  class = 'S1'><span>PartitionSL                               - Computes a partition of S w.r.t. a communication situation.</span></div><div  class = 'S1'><span>PermutationGame                           - Computes from an assignment matrix the permutation game.</span></div><div  class = 'S1'><span>PositionValue                             - Computes the position value.</span></div><div  class = 'S1'><span>Potential                                 - Determines the potential of a TU game (recursive).</span></div><div  class = 'S1'><span>PowerSet                                  - Computes all subsets from a set representation.</span></div><div  class = 'S1'><span>PreKernel                                 - Computes a prekernel element.</span></div><div  class = 'S1'><span>PreNucl                                   - Computes the prenucleolus using optimization toolbox.</span></div><div  class = 'S1'><span>PreNucl2                                  - Computes the prenucleolus using optimization toolbox.</span></div><div  class = 'S1'><span>PreNucl_llp                               - Computes the prenucleolus using optimization toolbox.</span></div><div  class = 'S1'><span>PrekernelQ                                - Checks if an imputation is a pre-kernel point.</span></div><div  class = 'S1'><span>PrenuclQ                                  - Checks if an imputation is the pre-nucleolus using Kohlberg's criterion.</span></div><div  class = 'S1'><span>PrkEqsModPrkQ  			    - Checks whether a pre-kernel element is also an element of the modified as well as proper modified pre-kernel	    </span></div><div  class = 'S1'><span>PropModPreKernel  			    - Computes from (v,x) a proper modified pre-kernel element from the dual cover game.</span></div><div  class = 'S1'><span>PropNucl                                  - Computes the proportional nucleolus.</span></div><div  class = 'S1'><span>PropPreNucl                               - Computes the proportional pre-nucleolus.</span></div><div  class = 'S1'><span>PRP_PROPERTYQ                             - Checks wheter the solution x satisfies the primal replication property.</span></div><div  class = 'S1'><span>REAS_LED_DCGame  			    - Verifies that x is a reasonable vector of game v, then the shifted  ducal cover game satisfies LED w.r.t. the replicated vector (x,x).</span></div><div  class = 'S1'><span>REAS_propertyQ  			    - Checks if the vector x satisfies the reasonableness on both sides</span></div><div  class = 'S1'><span>REC_propertyQ  			    - Checks whether the solution x satisfies reverse excess comparability.	    </span></div><div  class = 'S1'><span>RE_RGP  				    - Checks whether an imputation x is reasonable from both sides for all reduced games.</span></div><div  class = 'S1'><span>ReasSetEqsUpsQ                            - Checks if the reasonable set coincides with the upper set.</span></div><div  class = 'S1'><span>Reconfirmation_propertyQ                  - Checks the RCP.</span></div><div  class = 'S1'><span>RedGame                                   - Creates a Davis-Maschler reduced game.</span></div><div  class = 'S1'><span>Reduced_game_propertyQ                    - Checks the RGP.</span></div><div  class = 'S1'><span>SDCP_propertyQ  			    - Checks whether the solution x satisfies a strong dual cover property.</span></div><div  class = 'S1'><span>SDFP_propertyQ  			    - Checks whether the solution x satisfies a strong dual floor property.</span></div><div  class = 'S1'><span>SD_ShapleyValue  			    - Computes the surplus division Shapley value. </span></div><div  class = 'S1'><span>SED  					    - Computes the small excess difference w.r.t. the payoff x.</span></div><div  class = 'S1'><span>SED_propertyQ  			    - Checks whether the solution x satisfies small excess difference property.	    </span></div><div  class = 'S1'><span>SedcoconsQ  				    - Checks whether an imputation x satisfies small excess difference converse consistency.</span></div><div  class = 'S1'><span>Sedcons_propertyQ  			    - Checks whether an imputation x satisfies the sedcons property.</span></div><div  class = 'S1'><span>ShapleyQ                                  - Checks if the imputation x is a Shapley value of game v.</span></div><div  class = 'S1'><span>ShapleyValue                              - Computes the Shapley value (potential).</span></div><div  class = 'S1'><span>ShapleyValueLB                            - Computes the Shapley value from the linear basis.</span></div><div  class = 'S1'><span>ShapleyValueM                             - Computes the Shapley value based on all marginal contributions.</span></div><div  class = 'S1'><span>ShapleyValueML                            - Computes the Shapley value using multi-linear extension. </span></div><div  class = 'S1'><span>ShapleyValuePot                           - Computes the Shapley value and potential.</span></div><div  class = 'S1'><span>SolidarityShapleyValue                    - Determines the solidarity Shapley value. </span></div><div  class = 'S1'><span>SolidarityValue                           - Determines the solidarity value. </span></div><div  class = 'S1'><span>SortMg                                    - Sorts a sub/power set w.r.t. its cardinality.</span></div><div  class = 'S1'><span>StandardSolution                          - Determines the standard solution.</span></div><div  class = 'S1'><span>StrConverse_DGP_Q  			    - Checks whether an imputation x satisfies the strong converse derived game property.</span></div><div  class = 'S1'><span>StrConverse_RGP_Q                         - Checks the strong RGP.</span></div><div  class = 'S1'><span>StrLedcoconsQ  			    - Checks whether an imputation x satisfies satisfies strong large excess difference converse consistency.	    </span></div><div  class = 'S1'><span>StrSedcoconsQ  			    - Checks whether an imputation x satisfies satisfies strong small excess difference converse consistency (SEDCOCONS).	    </span></div><div  class = 'S1'><span>SubDual                                   - Determines the dual of a subgame.</span></div><div  class = 'S1'><span>SubGame                                   - Creates a subgame.</span></div><div  class = 'S1'><span>SubSets                                   - Creates all subsets of super set.</span></div><div  class = 'S1'><span>Sum_Marg_Contributions                    - Returns 1 whenever for a coalition the sum of marginal contributions is positive.</span></div><div  class = 'S1'><span>Talmudic_Rule                             - Computes the Talmudic rule.</span></div><div  class = 'S1'><span>TauValue                                  - Computes the Tau value.</span></div><div  class = 'S1'><span>UnionStableBasis                          - Determines a basis of a union stable system.</span></div><div  class = 'S1'><span>UpperPayoff                               - Computes the upper payoff and minimum claim vector of game v.</span></div><div  class = 'S1'><span>UtopiaPayoff                              - Computes the utopia and minimum claim vector of game v.</span></div><div  class = 'S1'><span>Weak_balancedCollectionQ                  - Checking weak Kohlberg's criterion.</span></div><div  class = 'S1'><span>ZeroOne_Normalization                     - Creates a zero-one normalized game.</span></div><div  class = 'S1'><span>additive_game                             - Creates an additive game.</span></div><div  class = 'S1'><span>admissibleGame                            - Computes a symmetric compromise admissible game.</span></div><div  class = 'S1'><span>airport_game                              - Computes from an airport problem the associated savings game.</span></div><div  class = 'S1'><span>airport_profit                            - Computes from a cost and benefit vector the associated surplus game.</span></div><div  class = 'S1'><span>anti_coreQ  				    - Checks the existence of the anti-core of game v.</span></div><div  class = 'S1'><span>apex_game                                 - Creates an apex game.</span></div><div  class = 'S1'><span>assignment_game                           - Creates an assignment game.</span></div><div  class = 'S1'><span>average_convexQ                           - Checks the Tu-game on average convexity.</span></div><div  class = 'S1'><span>average_excess                            - Computes the average excess of game v.</span></div><div  class = 'S1'><span>balancedCollectionQ                       - Checking Kohlberg's criterion.</span></div><div  class = 'S1'><span>balancedQ                                 - Verifies whether the collection of coalitions is balanced.</span></div><div  class = 'S1'><span>bankruptcy_airport                        - Computes from a bankruptcy problem the airport surplus game.</span></div><div  class = 'S1'><span>bankruptcy_game                           - Creates a bankruptcy game.</span></div><div  class = 'S1'><span>banzhaf                                   - Computes the Banzhaf value.</span></div><div  class = 'S1'><span>basis_coordinates                         - Determines the basis coordinates of a Tu game.</span></div><div  class = 'S1'><span>basis_game                                - Determines bases games.</span></div><div  class = 'S1'><span>belongToAntiCoreQ                         - Checks if a payoff vector belongs to the anti-core.</span></div><div  class = 'S1'><span>belongToCoreQ                             - Checks if a payoff vector belongs to the core.</span></div><div  class = 'S1'><span>belongToImputationSetQ                    - Checks if a payoff vector belongs to imputation set.</span></div><div  class = 'S1'><span>belongToLeastCoreQ                        - Checks if a payoff vector belongs to the least core.</span></div><div  class = 'S1'><span>belongToLowerSetQ                         - Checks if a payoff vector belongs to lower set.</span></div><div  class = 'S1'><span>belongToUpperSetQ                         - Checks if a payoff vector belongs to upper set.</span></div><div  class = 'S1'><span>cardinality_game                          - Assigns zero to a coalition of size&lt;=k&lt;n, otherwise its cardinality.</span></div><div  class = 'S1'><span>clToMatlab                                - Computes the unique integer representation of coalitions.</span></div><div  class = 'S1'><span>clp_kernel                                - Computes a kernel point using the CLP solver.</span></div><div  class = 'S1'><span>cls_kernel                                - Computes a kernel point using the CLS solver.</span></div><div  class = 'S1'><span>coeff_linearbasis                         - Determines the coefficients (dividends) of a linear basis from a TU game.</span></div><div  class = 'S1'><span>compromiseAdmissibleQ                     - Checks if the core cover a TU game v is non-empty.</span></div><div  class = 'S1'><span>compromiseStableQ                         - Checks if the game is compromise stable.</span></div><div  class = 'S1'><span>concave_gameQ                             - Checks the concavity of a Tu-game.</span></div><div  class = 'S1'><span>convex_gameQ                              - Checks the convexity of a Tu-game.</span></div><div  class = 'S1'><span>coreQ                                     - Checks the non-emptiness of the core.</span></div><div  class = 'S1'><span>cplex_AntiNucl                            - Computes the anti nucleolus of game v using the CPLEX solver.</span></div><div  class = 'S1'><span>cplex_AntiNucl_llp                        - Computes the anti nucleolus of game v using the CPLEX solver.</span></div><div  class = 'S1'><span>cplex_AntiPreNucl                         - Computes the anti prenucleolus using the CPLEX solver.</span></div><div  class = 'S1'><span>cplex_AntiPreNucl_llp                     - Computes the anti prenucleolus using the CPLEX solver.</span></div><div  class = 'S1'><span>cplex_AssignmentGame                      - Creates an assignment game using the CPLEX solver.</span></div><div  class = 'S1'><span>cplex_LeastCore                           - Computes the least core using cplexmex.</span></div><div  class = 'S1'><span>cplex_exact_game                          - Computes the exact game from v using the CPLEX solver.</span></div><div  class = 'S1'><span>cplex_kernel                              - Computes a kernel point using the CPLEX solver.</span></div><div  class = 'S1'><span>cplex_modiclus                            - Computes the modiclus of game v using cplexmex.</span></div><div  class = 'S1'><span>cplex_nucl                                - Computes the nucleolus using the CPLEX solver.</span></div><div  class = 'S1'><span>cplex_nucl_llp                            - Computes the nucleolus using the CPLEX solver.</span></div><div  class = 'S1'><span>cplex_prekernel                           - Computes a prekernel point using the CPLEX solver.</span></div><div  class = 'S1'><span>cplex_prenucl                             - Computes the prenucleolus using the CPLEX solver.</span></div><div  class = 'S1'><span>cplex_prenucl_llp                         - Computes the prenucleolus using the CPLEX solver.</span></div><div  class = 'S1'><span>critical_value1                           - Computes the biggest gain of any group of players.</span></div><div  class = 'S1'><span>critical_value2                           - Computes a critical value w.r.t. the strong epsilon-core.</span></div><div  class = 'S1'><span>critical_value_star                       - Computes a critical value which contains the intersection of the imputation and reasonable set</span></div><div  class = 'S1'><span>cvx_kernel                                - Computes a kernel point using the CVX solver. </span></div><div  class = 'S1'><span>cvx_prekernel                             - Computes a prekernel point using the CVX solver. </span></div><div  class = 'S1'><span>dual_game                                 - Creates the dual of a Tu-game.</span></div><div  class = 'S1'><span>equal_treatmentQ                          - Checks if a vector x satisfies ETP.</span></div><div  class = 'S1'><span>exact_game                                - Computes the exact game from v using Matlab's Optimization toolbox.</span></div><div  class = 'S1'><span>exact_gameQ  				    - Checks whether game v is an exact game using Matlab's Optimization toolbox.</span></div><div  class = 'S1'><span>excess                                    - Determines the excesses w.r.t. a payoff vector. </span></div><div  class = 'S1'><span>feasible_dividends                        - Computes a collection of feasible dividends.</span></div><div  class = 'S1'><span>formatPowerSet  			    - Formats the Matlab cell output that contains the representation of coalitions into matrix form.</span></div><div  class = 'S1'><span>gameToMama                                - Converts a TU-game into Mathematica representation.</span></div><div  class = 'S1'><span>gameToMatlab                              - Converts a Tu-game into Matlab representation.</span></div><div  class = 'S1'><span>game_Two                                  - Constructs a 2-game from the coalition size 2 and number of players.</span></div><div  class = 'S1'><span>game_basis                                - Computes a game basis of the n-person TU game space.</span></div><div  class = 'S1'><span>game_space                                - Computes the game space which replicates a payoff as a pre-kernel element.</span></div><div  class = 'S1'><span>genUnionStable                            - Creates a union stable system.</span></div><div  class = 'S1'><span>getgame                                   - Creates a Tu-game from the unanimity coordinates.</span></div><div  class = 'S1'><span>glpk_AntiNucl                             - Computes the anti nucleolus of game v using the GLPK solver.</span></div><div  class = 'S1'><span>glpk_AntiNucl_llp                         - Computes the anti nucleolus of game v using the GLPK solver.</span></div><div  class = 'S1'><span>glpk_AntiPreNucl                          - Computes the anti pre-nucleolus using the GLPK solver.</span></div><div  class = 'S1'><span>glpk_AntiPreNucl_llp                      - Computes the anti pre-nucleolus using the GLPK solver.</span></div><div  class = 'S1'><span>glpk_exact_game                           - Computes the exact game from v using the GLPK solver.</span></div><div  class = 'S1'><span>glpk_kernel                               - Computes a kernel point using the GLPK solver. </span></div><div  class = 'S1'><span>glpk_modiclus                             - Computes the modiclus of game v using glpkmex.</span></div><div  class = 'S1'><span>glpk_nucl                                 - Computes the nucleolus using the GLPK solver.</span></div><div  class = 'S1'><span>glpk_nucl_llp                             - Computes the nucleolus using the GLPK solver.</span></div><div  class = 'S1'><span>glpk_prekernel                            - Computes a prekernel point using the GLPK solver. </span></div><div  class = 'S1'><span>glpk_prenucl                              - Computes the prenucleolus using the GLPK solver.</span></div><div  class = 'S1'><span>glpk_prenucl_llp                          - Computes the prenucleolus using the GLPK solver.</span></div><div  class = 'S1'><span>greedy_bankruptcy                         - Creates the greedy bankruptcy game.</span></div><div  class = 'S1'><span>gurobi_AntiNucl                           - Computes the anti nucleolus of game v using the GUROBI solver.</span></div><div  class = 'S1'><span>gurobi_AntiNucl_llp                       - Computes the anti nucleolus of game v using the GUROBI solver.</span></div><div  class = 'S1'><span>gurobi_AntiPreNucl                        - Computes the anti prenucleolus using the GUROBI solver.</span></div><div  class = 'S1'><span>gurobi_AntiPreNucl_llp                    - Computes the anti prenucleolus using the GUROBI solver.</span></div><div  class = 'S1'><span>gurobi_AssignmentGame                     - Creates an assignment game using the GUROBI solver.</span></div><div  class = 'S1'><span>gurobi_exact_game                         - Computes the exact game from v using the GUROBI solver.</span></div><div  class = 'S1'><span>gurobi_kernel                             - Computes a kernel point using the GUROBI solver. </span></div><div  class = 'S1'><span>gurobi_modiclus                           - Computes the modiclus of game v using the GUROBI.</span></div><div  class = 'S1'><span>gurobi_nucl                               - Computes the nucleolus using the GUROBI solver.</span></div><div  class = 'S1'><span>gurobi_nucl_llp                           - Computes the nucleolus using the GUROBI solver.</span></div><div  class = 'S1'><span>gurobi_prekernel                          - Computes a prekernel point using the GUROBI solver. </span></div><div  class = 'S1'><span>gurobi_prenucl                            - Computes the prenucleolus using the GUROBI solver.</span></div><div  class = 'S1'><span>gurobi_prenucl_llp                        - Computes the prenucleolus using the GUROBI solver.</span></div><div  class = 'S1'><span>harsanyi_dividends                        - Determines the the unanimity coordinates.</span></div><div  class = 'S1'><span>holler                                    - Computes the Holler index.</span></div><div  class = 'S1'><span>homogeneous_representationQ               - Checks if the weighted majority game possesses a homogeneous representation.</span></div><div  class = 'S1'><span>hsl_prekernel                             - Computes a prekernel point using HSL solvers. </span></div><div  class = 'S1'><span>hypergraphQ                               - Checks whether the system is a hypergraph communication situation.</span></div><div  class = 'S1'><span>interest_game                             - Computes from an interest problem the corresponding game.</span></div><div  class = 'S1'><span>ipopt_kernel                              - Computes a kernel point using the IPOPT solver. </span></div><div  class = 'S1'><span>ipopt_prekernel                           - Computes a prekernel point using the IPOPT solver.</span></div><div  class = 'S1'><span>ireffq                                    - Checks if a payoff satisfies IR as well as the Eff property.</span></div><div  class = 'S1'><span>jury_game                                 - Computes from a quota and the number of jurors a simple game.</span></div><div  class = 'S1'><span>k_Converse_RGP_Q                          - Checks if an imputation satisfies the k-CRGP.</span></div><div  class = 'S1'><span>k_Reconfirmation_propertyQ                - Checks the k-RCP.</span></div><div  class = 'S1'><span>k_Reduced_game_propertyQ                  - Checks the k-RGP.</span></div><div  class = 'S1'><span>k_StrConverse_RGP_Q                       - Checks the strong k-CRGP. </span></div><div  class = 'S1'><span>k_anticover                               - Determines from the Tu-game the corresponding anti k-game.</span></div><div  class = 'S1'><span>k_concaveQ                                - Checks k-concavity of the Tu-game.</span></div><div  class = 'S1'><span>k_convexQ                                 - Checks k-convexity of the Tu-game.</span></div><div  class = 'S1'><span>k_cover                                   - Determines from the Tu-game the corresponding k-game.</span></div><div  class = 'S1'><span>kernelQ                                   - Checks if an imputation is a kernel point.</span></div><div  class = 'S1'><span>lin_prekernel                             - Computes a prekernel point using optimization toolbox.</span></div><div  class = 'S1'><span>linear_basis                              - Determines the linear basis of the n-person TU game space.</span></div><div  class = 'S1'><span>lowersetQ                                 - Checks the existence of the lower set. </span></div><div  class = 'S1'><span>market_game                               - Determines from two disjoint sets a market game.</span></div><div  class = 'S1'><span>mcst_game                                 - Computes from a cost matrix the corresponding mcst game.</span></div><div  class = 'S1'><span>mediation_game                            - Assigns its outside option to a coalition without player k (employer), the other players are the employees.</span></div><div  class = 'S1'><span>mex_coalitions                            - Computes the set of coalitions with maximum excesses</span></div><div  class = 'S1'><span>minNoBlockPayoff                          - Computes the minimum no blocking payoff from game v.</span></div><div  class = 'S1'><span>minimal_winning                           - Computes the minimal winning coalitions.</span></div><div  class = 'S1'><span>modiclusQ                                 - Verifies whether the set of induced coalitions is a bi-balanced collection.</span></div><div  class = 'S1'><span>monotone_gameQ                            - Checks monotonicity of the TU game.</span></div><div  class = 'S1'><span>monotonic_cover                           - Determines the monotonic cover from a TU game.</span></div><div  class = 'S1'><span>msk_AntiNucl                              - Computes the anti nucleolus of game v using the MOSEK solver.</span></div><div  class = 'S1'><span>msk_AntiNucl_llp                          - Computes the anti nucleolus of game v using the MoSEK solver.</span></div><div  class = 'S1'><span>msk_AntiPreKernel                         - Computes from (v,x) an anti pre-kernel element using MOSEKMEX.</span></div><div  class = 'S1'><span>msk_AntiPreNucl                           - Computes the anti prenucleolus using the MOSEK solver.</span></div><div  class = 'S1'><span>msk_AntiPreNucl_llp                       - Computes the anti prenucleolus using the MOSEK solver.</span></div><div  class = 'S1'><span>msk_AssignmentGame                        - Creates an assignment game using the MOSEK solver.</span></div><div  class = 'S1'><span>msk_exact_game                            - Computes the exact game from v using the MOSEK solver.</span></div><div  class = 'S1'><span>msk_kernel                                - Computes a kernel point using the MOSEK solver.</span></div><div  class = 'S1'><span>msk_modiclus                              - Computes the modiclus of game v using the MOSEK solver.</span></div><div  class = 'S1'><span>msk_nucl                                  - Computes the nucleolus using the MOSEK solver.</span></div><div  class = 'S1'><span>msk_nucl_llp                              - Computes the nucleolus using the MOSEK solver.</span></div><div  class = 'S1'><span>msk_prekernel                             - Computes a prekernel point using the MOSEK solver.</span></div><div  class = 'S1'><span>msk_prenucl                               - Computes the prenucleolus using the MOSEK solver.</span></div><div  class = 'S1'><span>msk_prenucl_llp                           - Computes the prenucleolus using the MOSEK solver.</span></div><div  class = 'S1'><span>near_ringQ                                - Checks if a collection of coalitions is a near ring. </span></div><div  class = 'S1'><span>nucl                                      - Computes the nucleolus using optimization toolbox.</span></div><div  class = 'S1'><span>nucl_llp                                  - Computes the nucleolus using optimization toolbox.</span></div><div  class = 'S1'><span>oases_kernel                              - Computes a kernel point using the OASES solver.</span></div><div  class = 'S1'><span>oases_prekernel                           - Computes a prekernel point using the OASES solver.</span></div><div  class = 'S1'><span>ols_prekernel                             - Computes a prekernel point using optimization toolbox.</span></div><div  class = 'S1'><span>potential                                 - Determines the potential of a TU game (basis).</span></div><div  class = 'S1'><span>product_game                              - Computes form a vector x the corresponding product game.</span></div><div  class = 'S1'><span>production_game                           - Creates an affine production game.</span></div><div  class = 'S1'><span>production_game_sq                        - Creates a quadratic production game. </span></div><div  class = 'S1'><span>profit_matrix                             - Creates the profit matrix of an assignment game. </span></div><div  class = 'S1'><span>proper_amount                             - Computes the largest amount players contribute to a proper coalition.</span></div><div  class = 'S1'><span>pure_overhead                             - Creates the matrix of pure overhead games.</span></div><div  class = 'S1'><span>qpBB_kernel                               - Computes a kernel point using the QPBB solver.</span></div><div  class = 'S1'><span>qpc_kernel                                - Computes a kernel point using the QPC solver.</span></div><div  class = 'S1'><span>qpc_prekernel                             - Computes a prekernel point using the QPC solver.</span></div><div  class = 'S1'><span>qrg_prekernel                             - Computes a prekernel point using qrginv instead of pinv.</span></div><div  class = 'S1'><span>quotas                                    - Determines the quotas of a game.</span></div><div  class = 'S1'><span>reasonable_outcome                        - Determines the reasonable outcome.</span></div><div  class = 'S1'><span>replicate_Shapley                         - Replicates the Shapley value for a game space. </span></div><div  class = 'S1'><span>replicate_prk                             - Replicates a pre-kernel solution as a pre-kernel of a game space. </span></div><div  class = 'S1'><span>savings_game                              - Creates a saving game from a cost game.</span></div><div  class = 'S1'><span>scrb_solution                             - Computes separable costs-remaining benefits allocation. </span></div><div  class = 'S1'><span>select_starting_pt                        - Selects a starting point for the pre-kernel computation.</span></div><div  class = 'S1'><span>semi_convexQ                              - Checks semi-convexity.</span></div><div  class = 'S1'><span>separable_cost_allocation                 - Computes the separable cost allocation.</span></div><div  class = 'S1'><span>separating_collectionQ                    - Verifies if a collection is separating.</span></div><div  class = 'S1'><span>shiftGame  				    - Computes from the game v the t-shift game of v.</span></div><div  class = 'S1'><span>simple_game                               - Creates a simple game.</span></div><div  class = 'S1'><span>sm_Kernel.m                               - Computes an element of the simplified Kernel of a game.</span></div><div  class = 'S1'><span>sm_PreKernel  			    - Computes an element of the simplified pre-kernel of game v.	    </span></div><div  class = 'S1'><span>sm_PreKernel.m                            - Computes an element of the simplified Pre-kernel of a game.</span></div><div  class = 'S1'><span>sm_PreNucl                                - Computes the simplified pre-nucleolus of a game.</span></div><div  class = 'S1'><span>sm_nucl                                   - Computes the simplified nucleolus of a game.</span></div><div  class = 'S1'><span>smallest_amount                           - Computes the smallest amount vector.</span></div><div  class = 'S1'><span>sortsets                                  - Sorts a sub/power set w.r.t. its cardinality.</span></div><div  class = 'S1'><span>streps_value                              - Determines the strong epsilon-game.</span></div><div  class = 'S1'><span>substitutes                               - Establishes which pair of players are substitutes.</span></div><div  class = 'S1'><span>super_additiveQ                           - Checks the Tu-game on super additivity.</span></div><div  class = 'S1'><span>symmetricQ                                - Checks if the game v is symmetric.</span></div><div  class = 'S1'><span>totallyBalancedQ  			    - Checks whether the core of all subgames is non-empty.</span></div><div  class = 'S1'><span>unanimity_games                           - Computes the unanimity coordinates.</span></div><div  class = 'S1'><span>union_stableQ                             - Checks whether a system is union stable.</span></div><div  class = 'S1'><span>uppersetQ                                 - Checks the existence of the upper set.</span></div><div  class = 'S1'><span>value_matrix  			    - Computes from an assignment matrix the corresponding value matrix for a permutation game.	    </span></div><div  class = 'S1'><span>vclToMatlab                               - Computes a Tu-game and the corresponding unique integer representation of coalitions</span></div><div  class = 'S1'><span>veto_players                              - Determines the veto players of a simple game. </span></div><div  class = 'S1'><span>weakly_sub_additiveQ                      - Checks the Tu-game on weakly sub additivity.</span></div><div  class = 'S1'><span>weakly_super_additiveQ                    - Checks the Tu-game on weakly super additivity.</span></div><div  class = 'S1'><span>weightedOwen                              - Computes the weighted Owen value.</span></div><div  class = 'S1'><span>weightedShapley                           - Computes the weighted Shapley value.</span></div><div  class = 'S1'><span>weightedSolidarity                        - Computes the weighted solidarity value.</span></div><div  class = 'S1'><span>weighted_majority                         - Creates a weighted majority game.</span></div><div  class = 'S1'><span>winning_coalitions                        - Determines the whole set of winning coalitions.</span></div><div  class = 'S1'><span>zero_monotonicQ                           - Checks zero monotonicity.</span></div><div  class = 'S1'><span>zero_normalization                        - Creates a zero normalized game.</span></div><div  class = 'S1'><span></span></div><h3  class = 'S3'><span>Class Objects</span></h3><div  class = 'S1'><span></span></div><div  class = 'S1'><span>TuACore                                   - subclass object of TuSol (anti-core plot).</span></div><div  class = 'S1'><span>TuAPrn                                     - subclass object of TuSol (anti pre-nucleolus from various solvers).</span></div><div  class = 'S1'><span>TuASol                                     - subclass object of TuGame (game solutions).</span></div><div  class = 'S1'><span>TuAVert                                    - subclass object of TuSol (anti-core vertices).</span></div><div  class = 'S1'><span>TuCons                                    - subclass object of TuSol (consistency).</span></div><div  class = 'S1'><span>TuCore                                     - subclass object of TuSol (core plot).</span></div><div  class = 'S1'><span>TuGame                                   - to perform several computations for retrieving and modifying game data.</span></div><div  class = 'S1'><span>TuKcons                                  - subclass object of TuSol (generalized consistency).</span></div><div  class = 'S1'><span>TuKrn                                      - subclass object of TuSol (kernel solutions from various solvers).</span></div><div  class = 'S1'><span>TuNuc                                     - subclass object of TuSol (nucleolus from various solvers).</span></div><div  class = 'S1'><span>TuPrk                                      - subclass object of TuSol (pre-kernel solutions from various solvers).</span></div><div  class = 'S1'><span>TuPrn                                      - subclass object of TuSol (pre-nucleolus from various solvers).</span></div><div  class = 'S1'><span>TuProp                                    - subclass object of TuGame (game properties).</span></div><div  class = 'S1'><span>TuRep                                     - subclass object of TuSol (prk replication).</span></div><div  class = 'S1'><span>TuShRep                                 - subclass object of TuSol (Shapley value replication).</span></div><div  class = 'S1'><span>TuSol                                      - subclass object of TuGame (game solutions).</span></div><div  class = 'S1'><span>TuVal                                      - subclass object of TuGame (fairness and related values).</span></div><div  class = 'S1'><span>TuVert                                     - subclass object of TuSol (core vertices).</span></div><div  class = 'S1'><span></span></div><h2  class = 'S2'><span>Main Functions: Parallel Computing</span></h2><div  class = 'S1'><span></span></div><div  class = 'S1'><span>p_ADvalue                                 - Computes the Aumann-Dreze value.</span></div><div  class = 'S1'><span>p_AllMarginalContributions                - Computes all marginal contributions of a Tu-game.</span></div><div  class = 'S1'><span>p_AntiBalancedSetQ                        - Verifies whether the set of induced coalitions is a anti balanced collection.</span></div><div  class = 'S1'><span>p_AntiB0_balancedCollectionQ              - Checks the reversal of weighted Kohlberg's criterion.</span></div><div  class = 'S1'><span>p_AntiReduced_game_propertyQ  	    - Checks whether an imputation x satisfies the anti-reduced game property.</span></div><div  class = 'S1'><span>p_Anti_Converse_DGP_Q  		    - Checks whether an imputation x satisfies the anti-converse derived game property.</span></div><div  class = 'S1'><span>p_Anti_Derived_game_propertyQ  	    - Checks whether an imputation x satisfies a modified anti-derived game property.</span></div><div  class = 'S1'><span>p_Anti_ModPreKernel  			    - Computes from (v,x) a modified pre-kernel element.</span></div><div  class = 'S1'><span>p_Anti_ModPrekernelQ  		    - Checks whether the imputation x is a modified anti-pre-kernel element of the TU-game v.</span></div><div  class = 'S1'><span>p_Anti_PModPreKernel  		    - Computes from (v,x) a proper modified anti-pre-kernel element.</span></div><div  class = 'S1'><span>p_Anti_PModPrekernelQ  		    - Checks whether the imputation x is a proper modified anti-pre-kernel element of the TU-game v.</span></div><div  class = 'S1'><span>p_Anti_PreKernel                          - Computes an anti-pre-kernel element.</span></div><div  class = 'S1'><span>p_Anti_PrekernelQ                         - Checks if an imputation is an anti prekernel point.</span></div><div  class = 'S1'><span>p_Anti_PropModPreKernel  		    - Computes from (v,x) a proper modified anti-pre-kernel element.</span></div><div  class = 'S1'><span>p_B0_balancedCollectionQ                  - Checking weak Kohlberg's criterion.</span></div><div  class = 'S1'><span>p_BestCoalitions                          - Computes  the set of most effective coalitions.</span></div><div  class = 'S1'><span>p_COV_propertyQ  			    - Verifies if the payoff x satisfies the covariance with strategic equivalence property w.r.t. (v,m,t).</span></div><div  class = 'S1'><span>p_CddExactGame                            - Computes the exact game from v (cddmex).</span></div><div  class = 'S1'><span>p_CddTotallyBalancedQ  		    - Checks whether the core of all subgames is non-empty (cddmex).</span></div><div  class = 'S1'><span>p_CoalitionSolidarity                     - Determines the coalition solidarity value.</span></div><div  class = 'S1'><span>p_Converse_DGP_Q  			    - Checks whether an imputation x satisfies the converse derived game property.</span></div><div  class = 'S1'><span>p_Converse_RGP_Q                          - Checks if an imputation satisfies the CRGP.</span></div><div  class = 'S1'><span>p_DM_AntiReduced_game  		    - Computes from (v,x) all anti-reduced games on S at x of game v.</span></div><div  class = 'S1'><span>p_DM_Anti_Derived_game  		    - Computes from (v,x) a modified Davis-Maschler anti-reduced game vS on S at x for game v.</span></div><div  class = 'S1'><span>p_DM_Derived_game  			    - Computes from (v,x) a modified Davis-Maschler reduced game vS on S at x for game v.</span></div><div  class = 'S1'><span>p_DM_Reduced_game                         - Computes all Davis-Maschler reduced games.</span></div><div  class = 'S1'><span>p_DecomposeGame                           - Computes the unique decomposition of a TU-game.</span></div><div  class = 'S1'><span>p_Derived_game_propertyQ  		    - Checks whether an imputation x satisfies a modifed derived game property.</span></div><div  class = 'S1'><span>p_DualCover  				    - The maximum characteristic values from the primal or dual game.</span></div><div  class = 'S1'><span>p_DualFloor  				    - The minimum characteristic values from the primal or dual game.</span></div><div  class = 'S1'><span>p_ECCoverGame  			    - Computes from (v,x) an excess comparability cover of game v.</span></div><div  class = 'S1'><span>p_ECFloorGame  			    - Computes from (v,x) an excess comparability floor of game v.</span></div><div  class = 'S1'><span>p_EC_DGP_Q  				    - Checks whether the solution x satisfies excess comparability for each derived game.</span></div><div  class = 'S1'><span>p_EC_RGP_Q  				    - Checks whether the solution x satisfies excess comparability for each reduced game.</span></div><div  class = 'S1'><span>p_EC_propertyQ  			    - Checks whether the solution x satisfies excess comparability.</span></div><div  class = 'S1'><span>p_Gap                                     - Determines the gap function.</span></div><div  class = 'S1'><span>p_HMS_AntiReduced_game  		    - Computes from (v,x) all Hart/Mas-Colell anti-reduced games on S at x of game v.</span></div><div  class = 'S1'><span>p_HMS_Anti_Derived_game  		    - Computes from (v,x,S) a modified Hart-Mas-Colell anti-reduced game vS on S at x for game v.</span></div><div  class = 'S1'><span>p_HMS_Derived_game  			    - Computes from (v,x,S) a modified Hart-Mas-Colell reduced game vS on S at x for game v.</span></div><div  class = 'S1'><span>p_HMS_ImputSavingReducedGame              - Computes from (v,x) all Hart/Mas-Colell ISR games.</span></div><div  class = 'S1'><span>p_HMS_Reduced_game                        - Creates all Hart/Mas-Colell reduced games. </span></div><div  class = 'S1'><span>p_ISRG_propertyQ                          - Checks whether an imputation x satisfies the ISR game property.</span></div><div  class = 'S1'><span>p_ImputSavingReducedGame                  - Computes from (v,x) all imputation saving reduced games.</span></div><div  class = 'S1'><span>p_Kernel                                  - Computes a kernel point using the optimization toolbox.</span></div><div  class = 'S1'><span>p_LS_Nucl                                 - Computes the least square nucleolus of a game.</span></div><div  class = 'S1'><span>p_LS_PreNucl                              - Computes the least square pre-nucleolus of a game.</span></div><div  class = 'S1'><span>p_LedcoconsQ  			    - Checks whether an imputation x satisfies large excess difference converse consistency. </span></div><div  class = 'S1'><span>p_Ledcons_propertyQ  			    - Checks whether an imputation x satisfies the ledcons property.</span></div><div  class = 'S1'><span>p_ModHoller  				    - Computes the modified Holler index from the set of winning coalitions.</span></div><div  class = 'S1'><span>p_ModPreKernel  			    - Computes from (v,x) a modified pre-kernel element.</span></div><div  class = 'S1'><span>p_ModPrekernelQ  			    - Checks whether the imputation x is a modified pre-kernel element.</span></div><div  class = 'S1'><span>p_MyersonValue                            - Computes the Myerson value of a Tu game.</span></div><div  class = 'S1'><span>p_NullPlayer_propertyQ                    - Verifies if x satisfies the null player property.</span></div><div  class = 'S1'><span>p_OwenValue                               - Computes the Owen value.</span></div><div  class = 'S1'><span>p_PModPreKernel  			    - Computes from (v,x) a proper modified pre-kernel element.</span></div><div  class = 'S1'><span>p_PModPrekernelQ  			    - Checks whether the imputation x is a proper modified pre-kernel element.</span></div><div  class = 'S1'><span>p_PermutationGame                         - Computes from an assignment matrix the permutation game.</span></div><div  class = 'S1'><span>p_PositionValue                           - Computes the position value.</span></div><div  class = 'S1'><span>p_PreKernel                               - Computes a pre-kernel element.</span></div><div  class = 'S1'><span>p_PrekernelQ                              - Checks if an imputation is a pre-kernel point.</span></div><div  class = 'S1'><span>p_PropModPreKernel  			    - Computes from (v,x) a proper modified pre-kernel element.</span></div><div  class = 'S1'><span>p_REAS_propertyQ  			    - Checks if the vector x satisfies the reasonableness on both sides.</span></div><div  class = 'S1'><span>p_REC_propertyQ  			    - Checks whether the solution x satisfies reverse excess comparability.</span></div><div  class = 'S1'><span>p_Reconfirmation_propertyQ                - Checks the RCP.</span></div><div  class = 'S1'><span>p_RedGame                                 - Creates a Davis-Maschler reduced game.</span></div><div  class = 'S1'><span>p_Reduced_game_propertyQ                  - Checks the RGP.</span></div><div  class = 'S1'><span>p_SD_ShapleyValue  			    - Computes the surplus division Shapley value.</span></div><div  class = 'S1'><span>p_SedcoconsQ  			    - Checks whether an imputation x satisfies small excess difference converse consistency.</span></div><div  class = 'S1'><span>p_Sedcons_propertyQ  			    - Checks whether an imputation x satisfies the sedcons property.</span></div><div  class = 'S1'><span>p_ShapleyQ                                - Checks if the imputation x is a Shapley value of game v.</span></div><div  class = 'S1'><span>p_ShapleyValue                            - Computes the Shapley value (potential).</span></div><div  class = 'S1'><span>p_ShapleyValueLB                          - Computes the Shapley value from the linear basis.</span></div><div  class = 'S1'><span>p_ShapleyValueM                           - Computes the Shapley value while relying on all marginal contributions.</span></div><div  class = 'S1'><span>p_ShapleyValueML                          - Computes the Shapley value using the multi-linear extension.</span></div><div  class = 'S1'><span>p_SolidarityShapleyValue                  - Determines the solidarity Shapley value. </span></div><div  class = 'S1'><span>p_SolidarityValue                         - Determines the solidarity value. </span></div><div  class = 'S1'><span>p_StrConverse_DGP_Q  			    - Checks whether an imputation x satisfies the strong converse derived game property.</span></div><div  class = 'S1'><span>p_StrConverse_RGP_Q  			    - Checks whether an imputation x satisfies the strong CRGP.</span></div><div  class = 'S1'><span>p_StrLedcoconsQ  			    - Checks whether an imputation x satisfies satisfies strong large excess difference converse consistency.</span></div><div  class = 'S1'><span>p_StrSedcoconsQ  			    - Checks whether an imputation x satisfies satisfies strong small excess difference converse consistency.</span></div><div  class = 'S1'><span>p_SubSets                                 - Creates all subsets of super set.</span></div><div  class = 'S1'><span>p_TauValue                                - Computes the Tau value.</span></div><div  class = 'S1'><span>p_airport_profit                          - Computes from a cost and benefit vector the associated surplus game.</span></div><div  class = 'S1'><span>p_assignment_game                         - Creates  an assignment game.</span></div><div  class = 'S1'><span>p_average_convexQ                         - Checks on average convexity.</span></div><div  class = 'S1'><span>p_balancedSetQ                            - Verifies whether the set of induced coalitions is a balanced collection. </span></div><div  class = 'S1'><span>p_banzhaf                                 - Computes  the Banzhaf value.</span></div><div  class = 'S1'><span>p_basis_coordinates                       - Determines the basis coordinates of a Tu game.</span></div><div  class = 'S1'><span>p_basis_game                              - Determines bases games.</span></div><div  class = 'S1'><span>p_cls_kernel                              - Computes a kernel point using the CLS solver.</span></div><div  class = 'S1'><span>p_clp_kernel                              - Computes a kernel point using the CLP solver.</span></div><div  class = 'S1'><span>p_coeff_linearbasis                       - Determines the coefficients (dividends) of a linear basis from a TU game.</span></div><div  class = 'S1'><span>p_convex_gameQ                            - Checks on convexity.</span></div><div  class = 'S1'><span>p_coreQ                                   - Checks the non-emptiness of the core.</span></div><div  class = 'S1'><span>p_cplex_AssignmentGame                    - Creates an assignment game using the CPLEX solver.</span></div><div  class = 'S1'><span>p_cplex_exact_game                        - Computes the exact game from v using the CPLEX solver.</span></div><div  class = 'S1'><span>p_cplex_kernel                            - Computes a kernel point using the CPLEX solver.</span></div><div  class = 'S1'><span>p_cplex_prekernel                         - Computes a prekernel point using the CPLEX solver.</span></div><div  class = 'S1'><span>p_cvx_kernel                              - Computes a kernel point using the CVX solver. </span></div><div  class = 'S1'><span>p_cvx_prekernel                           - Computes a prekernel point using the CVX solver. </span></div><div  class = 'S1'><span>p_equal_treatmentQ                        - Checks if a vector x satisfies ETP.</span></div><div  class = 'S1'><span>p_exact_game                              - Computes the exact game from v using Matlab's Optimization toolbox.</span></div><div  class = 'S1'><span>p_excess                                  - Computes the excesses.</span></div><div  class = 'S1'><span>p_game_basis                              - Computes a game basis of the n-person TU-game space.</span></div><div  class = 'S1'><span>p_game_space                              - Computes the game space which replicates a payoff as a pre-kernel element.</span></div><div  class = 'S1'><span>p_game_space_red                          - Computes the game space which replicates a payoff as a pre-kernel element.</span></div><div  class = 'S1'><span>p_genUnionStable                          - Creates a union stable system.</span></div><div  class = 'S1'><span>p_getgame                                 - Creates a Tu-game from the unanimity coordinates. </span></div><div  class = 'S1'><span>p_glpk_exact_game                         - Computes the exact game from v using the GLPK solver.</span></div><div  class = 'S1'><span>p_glpk_kernel                             - Computes a kernel point using the GLPK solver. </span></div><div  class = 'S1'><span>p_glpk_prekernel                          - Computes a prekernel point using the GLPK solver. </span></div><div  class = 'S1'><span>p_gurobi_AssignmentGame                   - Creates an assignment game using the GUROBI solver.</span></div><div  class = 'S1'><span>p_gurobi_exact_game                       - Computes the exact game from v using the GUROBI solver.</span></div><div  class = 'S1'><span>p_gurobi_kernel                           - Computes a kernel point using the GUROBI solver. </span></div><div  class = 'S1'><span>p_gurobi_prekernel                        - Computes a prekernel point using the GUROBI solver. </span></div><div  class = 'S1'><span>p_harsanyi_dividends                      - Determines the the unanimity coordinates.</span></div><div  class = 'S1'><span>p_holler                                  - Computes the Holler index.</span></div><div  class = 'S1'><span>p_homogeneous_representationQ             - Checks if the weighted majority game possesses a homogeneous representation.</span></div><div  class = 'S1'><span>p_hsl_prekernel                           - Computes a prekernel point using HSL solvers. </span></div><div  class = 'S1'><span>p_ipopt_kernel                            - Computes a kernel point using the IPOPT solver.</span></div><div  class = 'S1'><span>p_ipopt_prekernel                         - Computes a prekernel point using the IPOPT solver.</span></div><div  class = 'S1'><span>p_k_Converse_RGP_Q                        - Checks if an imputation satisfies the k-CRGP.</span></div><div  class = 'S1'><span>p_k_Reconfirmation_propertyQ              - Checks the k-RCP.</span></div><div  class = 'S1'><span>p_k_Reduced_game_propertyQ                - Checks the k-RGP.</span></div><div  class = 'S1'><span>p_k_StrConverse_RGP_Q                     - Checks the strong k-CRGP. </span></div><div  class = 'S1'><span>p_k_convexQ                               - Checks k-convexity of the Tu-game.</span></div><div  class = 'S1'><span>p_k_cover                                 - Determines from the Tu-game the corresponding k-game.</span></div><div  class = 'S1'><span>p_lin_prekernel                           - Computes a prekernel point using optimization toolbox.</span></div><div  class = 'S1'><span>p_linear_basis                            - Determines the linear basis of the n-person TU game space.</span></div><div  class = 'S1'><span>p_mcst_game                               - Computes from a cost matrix the corresponding mcst game.</span></div><div  class = 'S1'><span>p_minimal_winning                         - Computes the minimal winning coalitions.</span></div><div  class = 'S1'><span>p_monotone_gameQ                          - Checks monotonicity of the Tu-game.</span></div><div  class = 'S1'><span>p_msk_AssignmentGame                      - Creates an assignment game using the MOSEK solver.</span></div><div  class = 'S1'><span>p_msk_exact_game                          - Computes the exact game from v using the MOSEK solver.</span></div><div  class = 'S1'><span>p_msk_kernel                              - Computes a kernel point using the MOSEK solver.</span></div><div  class = 'S1'><span>p_msk_prekernel                           - Computes a prekernel point using the MOSEK solver.</span></div><div  class = 'S1'><span>p_oases_kernel                            - Computes a kernel point using the OASES solver.</span></div><div  class = 'S1'><span>p_oases_prekernel                         - Computes a prekernel point using the OASES solver.</span></div><div  class = 'S1'><span>p_ols_prekernel                           - Computes a prekernel point using optimization toolbox.</span></div><div  class = 'S1'><span>p_potential                               - Determines the potential of a TU game (basis).</span></div><div  class = 'S1'><span>p_pure_overhead                           - Creates the matrix of pure overhead games.</span></div><div  class = 'S1'><span>p_qpBB_kernel                             - Computes a kernel point using the QPBB solver.</span></div><div  class = 'S1'><span>p_qpc_kernel                              - Computes a kernel point using the QPC solver.</span></div><div  class = 'S1'><span>p_qpc_prekernel                           - Computes a prekernel point using the QPC solver.</span></div><div  class = 'S1'><span>p_qrg_prekernel                           - Computes a prekernel point using qrginv instead of pinv.</span></div><div  class = 'S1'><span>p_reasonable_outcome                      - Determines the reasonable outcome.</span></div><div  class = 'S1'><span>p_replicate_Shapley                       - Replicates the Shapley value for a game space. </span></div><div  class = 'S1'><span>p_replicate_prk                           - Replicates a pre-kernel solution as a pre-kernel of a game space. </span></div><div  class = 'S1'><span>p_select_starting_pt                      - Selects a starting point for the pre-kernel computation.</span></div><div  class = 'S1'><span>p_semi_convexQ                            - Checks semi-convexity.</span></div><div  class = 'S1'><span>p_sub_additiveQ                           - Checks the Tu-game on sub additivity.</span></div><div  class = 'S1'><span>p_substitutes                             - Establishes which pair of players are substitutes.</span></div><div  class = 'S1'><span>p_super_additiveQ                         - Checks the Tu-game on super additivity.</span></div><div  class = 'S1'><span>p_totallyBalancedQ  			    - checks whether the core of all subgames is non-empty.</span></div><div  class = 'S1'><span>p_unanimity_games                         - Computes the unanimity coordinates.</span></div><div  class = 'S1'><span>p_union_stableQ                           - Checks whether a system is union stable.</span></div><div  class = 'S1'><span>p_weightedOwen                            - Computes the weighted Owen value.</span></div><div  class = 'S1'><span>p_weightedShapley                         - Computes the weighted Shapley value.</span></div><div  class = 'S1'><span>p_winning_coalitions                      - Computes from a pre-defined set of minimal winning coalitions the whole set of winning coalitions.</span></div><div  class = 'S1'><span>p_zero_monotonicQ                         - Checks zero monotonicity.</span></div><div  class = 'S1'><span></span></div><h3  class = 'S3'><span>Class Objects</span></h3><div  class = 'S1'><span></span></div><div  class = 'S1'><span>p_TuCons                                  - subclass object of p_TuSol (consistency).</span></div><div  class = 'S1'><span>p_TuKcons                                 - subclass object of p_TuSol (generalized consistency).</span></div><div  class = 'S1'><span>p_TuKrn                                   - subclass object of p_TuSol (kernel solutions from various solvers).</span></div><div  class = 'S1'><span>p_TuPrk                                   - subclass object of p_TuSol (pre-kernel solutions from various solvers).</span></div><div  class = 'S1'><span>p_TuProp                                  - subclass object of TuGame (game properties).</span></div><div  class = 'S1'><span>p_TuRep                                   - subclass object of p_TuSol (prk replication).</span></div><div  class = 'S1'><span>p_TuShRep                                 - subclass object of p_TuSol (Shapley value replication).</span></div><div  class = 'S1'><span>p_TuSol                                   - subclass object of TuGame (game solutions).</span></div><div  class = 'S1'><span>p_TuVal                                   - subclass object of TuGame (fairness and related values).</span></div><div  class = 'S1'><span></span></div><h2  class = 'S2'><span>Tools: Sed File</span></h2><div  class = 'S1'><span></span></div><div  class = 'S1'><span>sed_core                                  - Converts cdd file format into Matlab format.</span></div></div>
<br>
<!-- 
##### SOURCE BEGIN #####
%% MatTuGames: A Matlab Game Theory Toolbox 
% Version 1.8 (R2019b) 31-Jan-2020
% 
% Author:        Holger I. Meinhardt 
% 
% E-Mail:        Holger.Meinhardt@wiwi.uni-karlsruhe.de
% 
% Institution:   University of Karlsruhe (KIT)
% 
% 
%% Some Auxiliary Files
% 
% 
% FrameToImage                              - Converts a frame to an image.
% 
% PlayCoreMovie                             - Plays a movie from a collection 
% of frames.
% 
% ginv                                              - Computes a general inverse.
% 
% myaa                                            - MYAA Render figure with 
% anti-aliasing.
% 
% qrginv                                           - Computes a pseudo-inverse 
% using a QR-method.
% 
% vtk_export                                    - Exportes the graphical raw 
% data to VTK legacy format.
% 
% 
% 
% 
%% Scirpt File
% 
% 
% corevert                                      - External bash script to call 
% the cdd library. 
% 
% 
%% Document Files                    
% 
% 
% MatTuGames_Version_1.8.m                  - Additions and changes in version 
% 1.8
% 
% ReadMe.pdf                                             - Installation instruction 
% (PDF)
% 
% ReadMe.md                                             - Installation instruction 
% (Markdown Format)
% 
% getting_started.m                                    - Checks the installation
% 
% getting_started.out                                  - Reference results of 
% getting_started
% 
% getting_started.md                                   - Reference results of 
% getting_started (Markdown Format)   
% 
% manual_mat_tugames.pdf                        - Manual (PDF)
% 
% MatTuGames_References.md                 - Bibliography (Markdown Format)
% 
% MatTuGames_References.pdf                - Bibliography (PDF)    
% 
% testcase_graphics                                    - Checking basic graphic 
% installation.
% 
% 
%% Graphic Example Files
% 
% 
% core_exp.pdf                                   - Core plot example 3d.
% 
% core_exp_all.pdf                             - Core plot example 3d.
% 
% core_exp_prk.pdf                            - Core plot example 3d.
% 
% core_exp_prn.pdf                            - Core plot example 3d.
% 
% core_exp_shap.pdf                         - Core plot example 3d.
% 
% core_exp_sol_all.pdf                       - Core plot example 3d.
% 
% core_exp_sol_none.pdf                   - Core plot example 3d.
% 
% core_exp_sol_prk.pdf                      - Core plot example 3d.
% 
% core_exp_sol_prn.pdf                     - Core plot example 3d.
% 
% core_exp_sol_shap.pdf                   - Core plot example 3d.
% 
% manual_exp2_core01.p                  - Core plot example 3d.
% 
% 
%% Mathematica Symbolic Toolbox Functions to call the Mathematica Package TuGames
% 
% 
% tug_AdjustedWorthVectors                  - Computes the adjusted worth vectors 
% of k-convex games.   
% 
% tug_AllAntiSurpluses                      - Computes the minimum surpluses.
% 
% tug_AllMaxSurpluses                       - Computes the maximum surpluses.
% 
% tug_AntiPreKernel                         - Computes an anti-pre-kernel point.
% 
% tug_AntiPreKernelQ                        - Checks if an imputation is an 
% anti-pre-kernel point.
% 
% tug_AvConvexQ                             - Checks on average convexity.
% 
% tug_AverageConvexQ                        - Checks on average convexity.
% 
% tug_BalancedKSelectionQ                   - Checks if an imputation induces 
% a k-balanced selection.
% 
% tug_BalancedSelectionQ                    - Checks if an imputation induces 
% a balanced selection.
% 
% tug_Bankruptcy                            - Creates a modest bankruptcy game.
% 
% tug_BelongToCoreQ                         - Checks if an imputation belongs 
% to the core.
% 
% tug_BestCoalToMatrix                      - Computes an equivalence matrix. 
% 
% tug_Bsc                                   - Returns the set of most effective 
% coalitions.
% 
% tug_CharacteristicValues                  - Computes the characteristic values.
% 
% tug_Coal2Dec                              - List of proper coalitions in Mathematica 
% order.
% 
% tug_CollectionBalancedQ                   - Checks if a collection is balanced.
% 
% tug_CollectionOfDecreasingExcess          - Creates the collection of decreasing 
% excesses.
% 
% tug_Concession                            - Computes the concession vector.
% 
% tug_ContestedGarment                      - Computes the contested garment. 
% 
% tug_ConvexQ                               - Checks convexity.
% 
% tug_ConvexUnanConditionQ                  - Checks convexity while relying 
% on the unanimity coordinates.
% 
% tug_CoreElementsQ                         - Checks if an imputation belongs 
% to the core.
% 
% tug_CoreQ                                 - Checks if the core is non-empty. 
% 
% tug_CostSavings                           - Creates the cost savings game.
% 
% tug_CriticalVal                           - Computes some critical epsilon 
% values.
% 
% tug_DetQuasiAvConvex                      - Determines a quasi average convex 
% game.
% 
% tug_DetRandCoord                          - Returns random unanimity coordinates.
% 
% tug_DetUCoord                             - Determines the missing unanimity 
% coordinates of size greater than 2. 
% 
% tug_Disagreement                          - Computes the disagreement vector.
% 
% tug_DualGame                              - Creates the dual of a Tu-game.
% 
% tug_EpsCore                               - Computes the least core.
% 
% tug_EqClass                               - Determines the equivalence classes 
% from the set of most effective coalitions.
% 
% tug_EvalSumMinCoord                       - Calculates at most (n-1) inequalities 
% of the unanimity coordinates constraints of nonnegative sums.
% 
% tug_ExcessValues                          - Determines the excesses.
% 
% tug_FindPreKernel                         - Computes a pre-kernel element.
% 
% tug_GameMonotoneQ                         - Checks on monotonicity.
% 
% tug_Gap                                   - Computes the gap function.
% 
% tug_GrandCoalitionLargestValueQ           - Checks if the grand coalition 
% has largest value.
% 
% tug_GreedyBankruptcy                      - Creates the greedy bankruptcy 
% game.
% 
% tug_HarsanyiDividends                     - Creates the unanimity coordinates.
% 
% tug_ImpToVec                              - Converts an imputation to a set 
% of vectors.
% 
% tug_ImputationQ                           - Checks if a payoff vector is an 
% imputation.
% 
% tug_IntersectionOfMaxExcessSets           - Determines if the set of proper 
% coalitions having largest excesses has an empty intersection.
% 
% tug_IntersectionUpperLowerSetQ            - Checks if the intersection of 
% the lower and upper set is non-empty. 
% 
% tug_Kernel                                - Computes a kernel point.
% 
% tug_KernelCalculation                     - Computes a or some kernel element(s).
% 
% tug_KernelImputationQ                     - Checks if an imputation is a kernel 
% point.
% 
% tug_KernelVertices                        - Computes a kernel segment.
% 
% tug_LargestAmount                         - Computes the largest amount.
% 
% tug_LeastCore                             - Determine the least core.
% 
% tug_LexiCenter                            - Computes the lexi center.
% 
% tug_LowerSetIncImputationQ                - Checks if the lower set is included 
% in the imputation set.
% 
% tug_LowerSetQ                             - Checks if an imputation belongs 
% to the lower set.
% 
% tug_MKernel                               - Determines a kernel point.
% 
% tug_MLExtension                           - Computes the multi-linear extension.
% 
% tug_MargValue                             - Determines the marginal contribution 
% vector.
% 
% tug_MaxExcessBalanced                     - Checks if the maximum surpluses 
% are balanced.
% 
% tug_MaxExcessSets                         - Computes the set of proper coalitions 
% having largest excesses.
% 
% tug_MinExcessBalanced                     - Determines if the minimum surpluses 
% are balanced.
% 
% tug_MinUnanimityCoordinates               - Returns the minimum unanimity 
% coordinates. 
% 
% tug_Mnuc                                  - Determines the nucleolus.
% 
% tug_MonotoneQ                             - Checks on monotonicity.
% 
% tug_Nuc                                   - Computes the nucleolus.
% 
% tug_OneNormalization                      - Creates a one normalized game.
% 
% tug_PreKernel                             - Computes a pre-kernel element.
% 
% tug_PreKernelEl                           - Computes a pre-kernel element.
% 
% tug_PreKernelEqualsKernelQ                - Checks if the pre-kernel coincides 
% with the kernel.
% 
% tug_PreKernelQ                            - Checks if an imputation is a pre-kernel 
% element.
% 
% tug_PreNuc                                - Computes the pre-nucleolus.
% 
% tug_ProperAmount                          - Computes the proper amount.
% 
% tug_Quota                                 - Computes the quotas.
% 
% tug_ReasonableOutcome                     - Computes the reasonable outcome.
% 
% tug_ReasonableSet                         - Computes the reasonable set.
% 
% tug_ScrbSolution                          - Determines the Scrb solution.
% 
% tug_SetsToVec                             - Converts the set of most effective 
% coalitions to a set of vectors.
% 
% tug_ShapleyValue                          - Determines the Shapley value.
% 
% tug_ShapleyValueML                        - Determines the Shapley value using 
% multi-linear extension.
% 
% tug_SmallestContribution                  - Determines the smallest contribution 
% vector.
% 
% tug_StrictlyConvexUnanConditionQ          - Examines the sufficient condition 
% of convexity in terms of unanimity coordinates.
% 
% tug_SuperAdditiveQ                        - Checks on super-additivity.
% 
% tug_SymGameSizeK                          - Returns a special type of symmetric 
% game.
% 
% tug_SymGameType2                          - Returns a special type of symmetric 
% game.
% 
% tug_SymGameType3                          - Returns a special type of symmetric 
% game.
% 
% tug_SymGameType4                          - Returns a special type of symmetric 
% game.
% 
% tug_TalmudicRule                          - Computes the Talmudic distribution 
% rule.
% 
% tug_TauValue                              - Determines the Tau value.
% 
% tug_UnanAvConvexQ                         - Checks if the coordinates satisfy 
% the sufficient and necessary condition of average convexity.
% 
% tug_UnanConvexQ                           - Checks if the coordinates satisfy 
% the sufficient and necessary condition of convexity.
% 
% tug_UnanimityCoordinates                  - Determines all unanimity coordinates 
% of the game
% 
% tug_UpperSetIncImputationQ                - Checks if the upper set is included 
% in the imputation set.
% 
% tug_UpperSetQ                             - Checks if an imputation belongs 
% to the upper set.
% 
% tug_UtopiaVector                          - Computes the utopia payoff. 
% 
% tug_ValueExcess                           - Computes an objective function 
% to compute a pre-kernel element.
% 
% tug_VerticesCore                          - Determines the vertices of the 
% core.
% 
% tug_WeaklySuperAdditiveQ                  - Checks if the Tu-game is weakly 
% super-additive.
% 
% tug_WeightedMajority                      - Creates the weighted majority 
% game.
% 
% tug_ZeroMonotoneQ                         - Checks on zero-monotonicity.
% 
% tug_ZeroNormalization                     - Creates the zero normalized game.
% 
% tug_ZeroOneNormalization                  - Creates the zero-one normalized 
% game.
% 
% tug_kCover                                - Determines from the Tu-game the 
% corresponding k-game.
% 
% 
%% Main Functions: Serial Computing
% 
% 
% ADvalue                                   - Computes the Aumann-Dreze value.
% 
% AdditiveQ                                 - Checks if the game v is additive.
% 
% AllMarginalContributions                  - Computes all marginal contributions 
% of a Tu game.
% 
% AllSubGames                               - Computes all subgames.
% 
% AntiCoreCoverQ                            - Checks if the anti-core cover 
% is non-empty.
% 
% AntiCorePlot                              - Plots the anti-core.
% 
% AntiCoreVertices                          - Evaluates the vertices of the 
% anti-core.
% 
% AntiImputationVertices                    - Computes all vertices of the anti 
% imputation set.
% 
% AntiReduced_game_propertyQ  		    - Checks whether an imputation x satisfies 
% the anti-reduced game property. 
% 
% AntiUtopiaPayoff                          - Computes the anti-utopia and agreement 
% vector.
% 
% Anti_B0_balancedCollectionQ               - Checks the reversal of weak Kohlberg's 
% criterion.
% 
% Anti_BestCoalitions  			    - Computes the set of less effective coalitions.
% 
% Anti_Converse_DGP_Q  			    - Checks whether an imputation x satisfies the 
% anti-converse derived game property.
% 
% Anti_DerivedGame  			    - Computes from (v,x,S) a modified Davis-Maschler 
% anti-derived game vS on S at x for game v.
% 
% Anti_Derived_game_propertyQ  		    - Checks whether an imputation x satisfies 
% a modified anti-derived game property.
% 
% Anti_Kernel                               - Computes an anti-kernel point.
% 
% Anti_ModPreKernel  			    - Computes from (v,x) an anti-modified pre-kernel 
% element.
% 
% Anti_ModPrekernelQ  			    - Checks whether the imputation x is a modified 
% anti-pre-kernel element of the TU-game v.
% 
% Anti_Nucl                                 - Computes the anti nucleolus of 
% a game.
% 
% Anti_Nucl_llp                             - Computes the anti nucleolus of 
% a game.
% 
% Anti_PModPreKernel  			    - Computes from (v,x) an anti-proper-modified pre-kernel 
% element.
% 
% Anti_PModPrekernelQ  			    - Checks whether the imputation x is a proper 
% modified anti-pre-kernel element of the TU-game v.
% 
% Anti_PreKernel                            - Computes an anti-prekernel point.
% 
% Anti_PreNucl                              - Computes the anti pre-nucleolus 
% of game v.
% 
% Anti_PreNucl_llp                          - Computes the anti pre-nucleolus 
% of game v.
% 
% Anti_PrekernelQ                           - Checks if an imputation is an 
% anti prekernel point.
% 
% Anti_PropModPreKernel  		    - Checks whether the imputation x is a proper 
% modified anti-pre-kernel element of the TU-game v.	    
% 
% Anti_balancedCollectionQ                  - Checks the reversal of Kohlberg's 
% criterion.
% 
% Anti_kernelQ                              - Checks if an imputation is an 
% anti kernel point.
% 
% B0_balancedCollectionQ                    - Checking weak Kohlberg's criterion.
% 
% B0_balancedQ                              - Verifies whether the collection 
% of coalitions is weakly balanced.
% 
% BestCoalitions                            - Computes the set of most effective 
% coalitions.
% 
% COV_propertyQ                             - Verifies if the payoff x satisfies 
% COV property.
% 
% CddAntiCoreCoverPlot                      - Plots the anti-core cover set.
% 
% CddAntiCoreCoverVertices                  - Computes all vertices of the anti-core 
% cover set.
% 
% CddAntiCorePlot                           - Plots the anti-core of a game 
% using cddmex. 
% 
% CddAntiCoreQ                              - Checks if the anti-core exists 
% (cddmex).
% 
% CddAntiCoreSimplexPlot                    - Plots the anti-core using simplex 
% projection.
% 
% CddAntiCoreSimplexVertices                - Computes all anti-core vertices 
% using simplex projection.
% 
% CddAntiCoreVertices                       - Computes the vertices of the anti-core 
% (cddmex).
% 
% CddAntiImputationSimplexVertices          - Computes all vertices of the anti-imputation 
% set using simplex projection.
% 
% CddAntiImputationVertices                 - Computes all vertices of the anti-imputation 
% set.
% 
% CddAntiLeastCore                          - Computes the least core of game 
% v using (cddmex).
% 
% CddAntiLeastCoreVertices                  - Computes the vertices of the anti 
% least core of game v (cddmex).
% 
% CddAntiNucl                               - Computes the anti nucleolus of 
% game v (cddmex).
% 
% CddAntiNucl_llp                           - Computes the anti nucleolus of 
% game v (cddmex).
% 
% CddAntiPrenucl                            - Computes the anti pre-nucleolus 
% of game v (cddmex).
% 
% CddAntiPrenucl_llp                        - Computes the anti pre-nucleolus 
% of game v (cddmex).
% 
% CddBelongToLeastCoreQ                     - Checks if a payoff vector belongs 
% to the least-core.
% 
% CddCoreCoverPlot                          - Plots the core cover of a TU game.
% 
% CddCoreCoverSimplexPlot                   - Plots the core cover (simplex 
% projection).
% 
% CddCoreCoverSimplexVertices               - Computes all vertices of the core 
% cover (simplex).
% 
% CddCoreCoverVertices                      - Computes all vertices of the core 
% cover of a TU game.
% 
% CddCoreMovie                              - Creates a movie w.r.t. the strong 
% epsilon-cores.
% 
% CddCorePlot                               - Plots the core of a game using 
% cddmex. 
% 
% CddCoreQ                                  - Checks if the core exists (cddmex).
% 
% CddCoreSimplexMovie                       - Creates a movie w.r.t. the strong 
% epsilon-cores (simplex projection).
% 
% CddCoreSimplexPlot                        - Plots the core (simplex projection).
% 
% CddCoreSimplexVertices                    - Computes the vertices of the core 
% (simplex).
% 
% CddCoreVertices                           - Computes the vertices of the core 
% (cddmex).
% 
% CddExactGame                              - Computes the exact game from v 
% (cddmex).
% 
% CddImputationSimplexVertices              - Computes the vertices of the imputation 
% set (simplex).
% 
% CddImputationVertices                     - Computes the vertices of the imputation 
% set (cddmex).
% 
% CddKernelCatchers                         - Draws some kernel catchers (cddmex).
% 
% CddKernelCatchersSimplex                  - Draws some kernel catchers (simplex).
% 
% CddLeastCore                              - Computes the leastcore (cddmex).
% 
% CddLeastCoreVertices                      - Computes the leastcore vertices 
% (cddmex). 
% 
% CddLowerSetSimplexVertices                - Computes the vertices of the lower 
% set (simplex). 
% 
% CddLowerSetVertices                       - Computes the vertices of the lower 
% set (cddmex). 
% 
% CddModiclus                               - Computes the modiclus of game 
% v using cddmex.
% 
% CddNucl                                   - Computes the nucleolus using the 
% CDD solver (cddmex).
% 
% CddNucl_llp                               - Computes the nucleolus using the 
% CDD solver (cddmex).
% 
% CddPreKernel                              - Computes a pre-kernel element 
% (cddmex).
% 
% CddPrenucl                                - Computes the prenucleolus using 
% the CDD solver (cddmex).
% 
% CddPrenucl_llp                            - Computes the prenucleolus using 
% the CDD solver (cddmex).
% 
% CddReasonableSetSimplexVertices           - Computes the vertices of the reasonable 
% set (simplex). 
% 
% CddReasonableSetVertices                  - Computes the vertices of the reasonable 
% set (cddmex). 
% 
% CddStrongCorePlot                         - Plots a strong epsilon core. 
% 
% CddStrongCoreSimplexPlot                  - Plots the strong epsilon core 
% (simplex projection).
% 
% CddTotallyBalancedQ  			    - Checks whether the core of all subgames is non-empty 
% (cddmex).
% 
% CddUpperSetSimplexVertices                - Computes the vertices of the upper 
% set (simplex). 
% 
% CddUpperSetVertices                       - Computes the vertices of the upper 
% set (cddmex). 
% 
% CddWeberSet                               - Computes the vertices of the Weber 
% Set.
% 
% CddWeberSetPlot                           - Plots the Weber set.
% 
% CddWeberSetSimplex                        - Computes the vertices of the Weber 
% Set (simplex).
% 
% CddWeberSetSimplexPlot                    - Plots the Weber set (simplex).
% 
% CoalitionSolidarity                       - Determines the coalition solidarity 
% value.
% 
% ConstantSumQ                              - Checks if the game v has constant-sum.
% 
% Converse_DGP_Q  			    - Checks whether an imputation x satisfies the converse 
% derived game property.
% 
% Converse_RGP_Q                            - Checks if an imputation satisfies 
% the CRGP.
% 
% CoreCoverQ                                - Checks if the core cover a TU 
% game v is non-empty.
% 
% CorePlot                                  - Plots the core.
% 
% CoreVertices                              - Computes the vertices of the core.
% 
% DCP_propertyQ  			    - Checks whether the solution x satisfies the dual cover 
% property.	    
% 
% DFP_propertyQ  			    - Checks whether the solution x satisfies the dual floor 
% property.	    
% 
% DM_AntiReduced_game  			    - Computes from (v,x) all anti-reduced games on 
% S at x of game v.
% 
% DM_Anti_Derived_game  		    - Computes from (v,x) a modified Davis-Maschler 
% anti-reduced game vS on S at x for game v.
% 
% DM_Derived_game  			    - Computes from (v,x) a modified Davis-Maschler reduced 
% game vS on S at x for game v.
% 
% DM_Reduced_game                           - Computes all Davis-Maschler reduced 
% games.
% 
% DM_TwoPersonGame                          - Computes from (v,x) all reduced 
% two-person games.
% 
% DM_TwoReduced_game  			    - Computes from (v,x) all single and two-person 
% reduced games on S at x of game v.
% 
% DRP_propertyQ  			    - Checks whether the solution x satisfies the dual replication 
% property.	    
% 
% DecomposeGame                             - Computes the unique decomposition 
% of a TU-game.
% 
% DerivedGame  				    - Computes from (v,x,S) a modified Davis-Maschler derived 
% game vS on S at x for game v.
% 
% Derived_game_propertyQ  		    - Checks whether an imputation x satisfies a 
% modified derived game property.
% 
% DiscShapleyValue                          - Computes the discounted Shapley 
% value.
% 
% DualCover  				    - Computes the maximum characteristic values from the primal 
% or dual game.
% 
% DualFloor  				    - Computes the minimum characteristic values from the primal 
% or dual game.
% 
% Dual_Floor_game  			    - Computes from (v,x) a modified Davis-Maschler the 
% anti reduced game vS on S at x for game v.
% 
% Dual_Floor_propertyQ  		    - Checks whether an imputation x satisfies a modified 
% anti reduced game property	    
% 
% Dual_Cover_game  			    - Computes from (v,x) a modified Davis-Maschler reduced 
% game vS on S at x for game v.
% 
% Dual_Cover_propertyQ  		    - Checks whether an imputation x satisfies a modified 
% reduced game property	    
% 
% DuttaRay  				    - Computes the Dutta-Ray solution for convex games.
% 
% ECCoverGame  				    - Computes from (v,x) an excess comparability cover of 
% game v.
% 
% ECFloorGame  				    - Computes from (v,x) an excess comparability floor of 
% game v.
% 
% EC_DGP_Q  				    - Checks whether the solution x satisfies excess comparability 
% for each derived game.
% 
% EC_RGP_Q  				    - Checks whether the solution x satisfies excess comparability 
% for each reduced game.
% 
% EC_propertyQ  			    - Checks whether the solution x satisfies excess comparability.	    
% 
% ESD                                       - Computes the equal surplus division 
% of a TU-game.
% 
% EssentialQ                                - Checks if the game v is essential.
% 
% FlatQ                                     - Checks if the game v is flat.
% 
% Gap                                       - Determines the gap function.
% 
% HMS_AntiReduced_game  		    - Computes from (v,x) all Hart/Mas-Colell anti-reduced 
% games on S at x of game v.	    
% 
% HMS_Anti_Derived_game  		    - Computes from (v,x,S) a modified Hart-Mas-Colell 
% anti-reduced game vS on S at x for game v.	    
% 
% HMS_Derived_game  			    - Computes from (v,x,S) a modified Hart-Mas-Colell 
% reduced game vS on S at x for game v.
% 
% HMS_DervGame  			    - Computes from (v,x,S) a modified Hart-Mas-Colell derived 
% game vS on S at x for game v.	    
% 
% HMS_ImputSavingReducedGame                - Computes from (v,x) all Hart/Mas-Colell 
% ISR games.
% 
% HMS_RedGame  				    - Computes from (v,x,S) a Hart-MasColell reduced game 
% vS on S at x for game v.
% 
% HMS_Reduced_game                          - Creates all Hart/Mas-Colell reduced 
% games. 
% 
% HMS_TwoReduced_game  			    - Computes from (v,x) all Hart/Mas-Colell singleton 
% and two-person reduced games on S at x of game v.
% 
% ISRG_propertyQ                            - Checks whether an imputation x 
% satisfies the ISR game property.
% 
% ImpSetEqsLwsQ                             - Checks if the imputation set coincides 
% with the lower set.
% 
% ImputSavingReducedGame                    - Computes from (v,x) all imputation 
% saving reduced games.
% 
% ImputationVertices                        - Computes the vertices of the imputation 
% set.
% 
% InteractionSets                           - Determines a system of interaction 
% sets.
% 
% Kernel                                    - Computes a kernel point using 
% optimization toolbox.
% 
% KrEqsPrkQ                                 - Checks if the kernel is equal 
% to the pre-kernel.
% 
% LED  					    - Computes the large excess difference w.r.t. the payoff x.	    
% 
% LED_propertyQ  			    - Checks whether the solution x satisfies large excess 
% difference property.	    
% 
% LS_Nucl                                   - Computes the least square nucleolus 
% of a game.
% 
% LS_PreNucl                                - Computes the least square pre-nucleolus 
% of a game.
% 
% LeastCore                                 - Computes the leastcore using optimization 
% toolbox.
% 
% LeastCoreVertices                         - Computes the leastcore vertices. 
% 
% LedcoconsQ  				    - Checks whether an imputation x satisfies large excess 
% difference converse consistency.
% 
% Ledcons_propertyQ  			    - Checks whether an imputation x satisfies the ledcons 
% property 
% 
% LorenzDom                                 - Checks if x Lorenz dominates y 
% in game v.
% 
% LorenzSet                                 - Determines the Lorenz set of game 
% v.
% 
% LorenzSol  				    - Determines the Lorenz solution of game v.
% 
% MLextension                               - Computes the multi-linear extension.
% 
% MMExcess  				    - Computes the minimal and maximal excess vector of game 
% v and its dual.
% 
% ModHoller  				    - Computes a modified Holler index from the set of winning 
% coalitions.
% 
% ModPreKernel  			    - Computes from (v,x) a modified pre-kernel element.	    
% 
% ModPrekernelQ  			    - Checks whether the imputation x is a modified pre-kernel 
% element of the TU-game v.	    
% 
% Modiclus                                  - Computes the modiclus of a game.
% 
% MyersonValue                              - Computes the Myerson value of 
% a Tu game.
% 
% NullPlayer_propertyQ                      - Verifies if x satisfies the null 
% player property.
% 
% One_Normalization                         - Computes from the game v the corresponding 
% one-normalized game.
% 
% OwenValue                                 - Computes the Owen value.
% 
% PModPreKernel  			    - Computes from (v,x) a proper modified pre-kernel element.	    
% 
% PModPrekernelQ  			    - Checks whether the imputation x is a proper modified 
% pre-kernel element of the TU-game v.
% 
% PRP_propertyQ  			    - Checks whether the solution x satisfies the primal 
% replication property.	    
% 
% PartitionSA                               - Computes a partition of S w.r.t. 
% a hypergraph communication situation.
% 
% PartitionSL                               - Computes a partition of S w.r.t. 
% a communication situation.
% 
% PermutationGame                           - Computes from an assignment matrix 
% the permutation game.
% 
% PositionValue                             - Computes the position value.
% 
% Potential                                 - Determines the potential of a 
% TU game (recursive).
% 
% PowerSet                                  - Computes all subsets from a set 
% representation.
% 
% PreKernel                                 - Computes a prekernel element.
% 
% PreNucl                                   - Computes the prenucleolus using 
% optimization toolbox.
% 
% PreNucl2                                  - Computes the prenucleolus using 
% optimization toolbox.
% 
% PreNucl_llp                               - Computes the prenucleolus using 
% optimization toolbox.
% 
% PrekernelQ                                - Checks if an imputation is a pre-kernel 
% point.
% 
% PrenuclQ                                  - Checks if an imputation is the 
% pre-nucleolus using Kohlberg's criterion.
% 
% PrkEqsModPrkQ  			    - Checks whether a pre-kernel element is also an element 
% of the modified as well as proper modified pre-kernel	    
% 
% PropModPreKernel  			    - Computes from (v,x) a proper modified pre-kernel 
% element from the dual cover game.
% 
% PropNucl                                  - Computes the proportional nucleolus.
% 
% PropPreNucl                               - Computes the proportional pre-nucleolus.
% 
% PRP_PROPERTYQ                             - Checks wheter the solution x satisfies 
% the primal replication property.
% 
% REAS_LED_DCGame  			    - Verifies that x is a reasonable vector of game v, 
% then the shifted  ducal cover game satisfies LED w.r.t. the replicated vector 
% (x,x).
% 
% REAS_propertyQ  			    - Checks if the vector x satisfies the reasonableness 
% on both sides
% 
% REC_propertyQ  			    - Checks whether the solution x satisfies reverse excess 
% comparability.	    
% 
% RE_RGP  				    - Checks whether an imputation x is reasonable from both sides 
% for all reduced games.
% 
% ReasSetEqsUpsQ                            - Checks if the reasonable set coincides 
% with the upper set.
% 
% Reconfirmation_propertyQ                  - Checks the RCP.
% 
% RedGame                                   - Creates a Davis-Maschler reduced 
% game.
% 
% Reduced_game_propertyQ                    - Checks the RGP.
% 
% SDCP_propertyQ  			    - Checks whether the solution x satisfies a strong 
% dual cover property.
% 
% SDFP_propertyQ  			    - Checks whether the solution x satisfies a strong 
% dual floor property.
% 
% SD_ShapleyValue  			    - Computes the surplus division Shapley value. 
% 
% SED  					    - Computes the small excess difference w.r.t. the payoff x.
% 
% SED_propertyQ  			    - Checks whether the solution x satisfies small excess 
% difference property.	    
% 
% SedcoconsQ  				    - Checks whether an imputation x satisfies small excess 
% difference converse consistency.
% 
% Sedcons_propertyQ  			    - Checks whether an imputation x satisfies the sedcons 
% property.
% 
% ShapleyQ                                  - Checks if the imputation x is 
% a Shapley value of game v.
% 
% ShapleyValue                              - Computes the Shapley value (potential).
% 
% ShapleyValueLB                            - Computes the Shapley value from 
% the linear basis.
% 
% ShapleyValueM                             - Computes the Shapley value based 
% on all marginal contributions.
% 
% ShapleyValueML                            - Computes the Shapley value using 
% multi-linear extension. 
% 
% ShapleyValuePot                           - Computes the Shapley value and 
% potential.
% 
% SolidarityShapleyValue                    - Determines the solidarity Shapley 
% value. 
% 
% SolidarityValue                           - Determines the solidarity value. 
% 
% SortMg                                    - Sorts a sub/power set w.r.t. its 
% cardinality.
% 
% StandardSolution                          - Determines the standard solution.
% 
% StrConverse_DGP_Q  			    - Checks whether an imputation x satisfies the strong 
% converse derived game property.
% 
% StrConverse_RGP_Q                         - Checks the strong RGP.
% 
% StrLedcoconsQ  			    - Checks whether an imputation x satisfies satisfies 
% strong large excess difference converse consistency.	    
% 
% StrSedcoconsQ  			    - Checks whether an imputation x satisfies satisfies 
% strong small excess difference converse consistency (SEDCOCONS).	    
% 
% SubDual                                   - Determines the dual of a subgame.
% 
% SubGame                                   - Creates a subgame.
% 
% SubSets                                   - Creates all subsets of super set.
% 
% Sum_Marg_Contributions                    - Returns 1 whenever for a coalition 
% the sum of marginal contributions is positive.
% 
% Talmudic_Rule                             - Computes the Talmudic rule.
% 
% TauValue                                  - Computes the Tau value.
% 
% UnionStableBasis                          - Determines a basis of a union 
% stable system.
% 
% UpperPayoff                               - Computes the upper payoff and 
% minimum claim vector of game v.
% 
% UtopiaPayoff                              - Computes the utopia and minimum 
% claim vector of game v.
% 
% Weak_balancedCollectionQ                  - Checking weak Kohlberg's criterion.
% 
% ZeroOne_Normalization                     - Creates a zero-one normalized 
% game.
% 
% additive_game                             - Creates an additive game.
% 
% admissibleGame                            - Computes a symmetric compromise 
% admissible game.
% 
% airport_game                              - Computes from an airport problem 
% the associated savings game.
% 
% airport_profit                            - Computes from a cost and benefit 
% vector the associated surplus game.
% 
% anti_coreQ  				    - Checks the existence of the anti-core of game v.
% 
% apex_game                                 - Creates an apex game.
% 
% assignment_game                           - Creates an assignment game.
% 
% average_convexQ                           - Checks the Tu-game on average 
% convexity.
% 
% average_excess                            - Computes the average excess of 
% game v.
% 
% balancedCollectionQ                       - Checking Kohlberg's criterion.
% 
% balancedQ                                 - Verifies whether the collection 
% of coalitions is balanced.
% 
% bankruptcy_airport                        - Computes from a bankruptcy problem 
% the airport surplus game.
% 
% bankruptcy_game                           - Creates a bankruptcy game.
% 
% banzhaf                                   - Computes the Banzhaf value.
% 
% basis_coordinates                         - Determines the basis coordinates 
% of a Tu game.
% 
% basis_game                                - Determines bases games.
% 
% belongToAntiCoreQ                         - Checks if a payoff vector belongs 
% to the anti-core.
% 
% belongToCoreQ                             - Checks if a payoff vector belongs 
% to the core.
% 
% belongToImputationSetQ                    - Checks if a payoff vector belongs 
% to imputation set.
% 
% belongToLeastCoreQ                        - Checks if a payoff vector belongs 
% to the least core.
% 
% belongToLowerSetQ                         - Checks if a payoff vector belongs 
% to lower set.
% 
% belongToUpperSetQ                         - Checks if a payoff vector belongs 
% to upper set.
% 
% cardinality_game                          - Assigns zero to a coalition of 
% size<=k<n, otherwise its cardinality.
% 
% clToMatlab                                - Computes the unique integer representation 
% of coalitions.
% 
% clp_kernel                                - Computes a kernel point using 
% the CLP solver.
% 
% cls_kernel                                - Computes a kernel point using 
% the CLS solver.
% 
% coeff_linearbasis                         - Determines the coefficients (dividends) 
% of a linear basis from a TU game.
% 
% compromiseAdmissibleQ                     - Checks if the core cover a TU 
% game v is non-empty.
% 
% compromiseStableQ                         - Checks if the game is compromise 
% stable.
% 
% concave_gameQ                             - Checks the concavity of a Tu-game.
% 
% convex_gameQ                              - Checks the convexity of a Tu-game.
% 
% coreQ                                     - Checks the non-emptiness of the 
% core.
% 
% cplex_AntiNucl                            - Computes the anti nucleolus of 
% game v using the CPLEX solver.
% 
% cplex_AntiNucl_llp                        - Computes the anti nucleolus of 
% game v using the CPLEX solver.
% 
% cplex_AntiPreNucl                         - Computes the anti prenucleolus 
% using the CPLEX solver.
% 
% cplex_AntiPreNucl_llp                     - Computes the anti prenucleolus 
% using the CPLEX solver.
% 
% cplex_AssignmentGame                      - Creates an assignment game using 
% the CPLEX solver.
% 
% cplex_LeastCore                           - Computes the least core using 
% cplexmex.
% 
% cplex_exact_game                          - Computes the exact game from v 
% using the CPLEX solver.
% 
% cplex_kernel                              - Computes a kernel point using 
% the CPLEX solver.
% 
% cplex_modiclus                            - Computes the modiclus of game 
% v using cplexmex.
% 
% cplex_nucl                                - Computes the nucleolus using the 
% CPLEX solver.
% 
% cplex_nucl_llp                            - Computes the nucleolus using the 
% CPLEX solver.
% 
% cplex_prekernel                           - Computes a prekernel point using 
% the CPLEX solver.
% 
% cplex_prenucl                             - Computes the prenucleolus using 
% the CPLEX solver.
% 
% cplex_prenucl_llp                         - Computes the prenucleolus using 
% the CPLEX solver.
% 
% critical_value1                           - Computes the biggest gain of any 
% group of players.
% 
% critical_value2                           - Computes a critical value w.r.t. 
% the strong epsilon-core.
% 
% critical_value_star                       - Computes a critical value which 
% contains the intersection of the imputation and reasonable set
% 
% cvx_kernel                                - Computes a kernel point using 
% the CVX solver. 
% 
% cvx_prekernel                             - Computes a prekernel point using 
% the CVX solver. 
% 
% dual_game                                 - Creates the dual of a Tu-game.
% 
% equal_treatmentQ                          - Checks if a vector x satisfies 
% ETP.
% 
% exact_game                                - Computes the exact game from v 
% using Matlab's Optimization toolbox.
% 
% exact_gameQ  				    - Checks whether game v is an exact game using Matlab's 
% Optimization toolbox.
% 
% excess                                    - Determines the excesses w.r.t. 
% a payoff vector. 
% 
% feasible_dividends                        - Computes a collection of feasible 
% dividends.
% 
% formatPowerSet  			    - Formats the Matlab cell output that contains the 
% representation of coalitions into matrix form.
% 
% gameToMama                                - Converts a TU-game into Mathematica 
% representation.
% 
% gameToMatlab                              - Converts a Tu-game into Matlab 
% representation.
% 
% game_Two                                  - Constructs a 2-game from the coalition 
% size 2 and number of players.
% 
% game_basis                                - Computes a game basis of the n-person 
% TU game space.
% 
% game_space                                - Computes the game space which 
% replicates a payoff as a pre-kernel element.
% 
% genUnionStable                            - Creates a union stable system.
% 
% getgame                                   - Creates a Tu-game from the unanimity 
% coordinates.
% 
% glpk_AntiNucl                             - Computes the anti nucleolus of 
% game v using the GLPK solver.
% 
% glpk_AntiNucl_llp                         - Computes the anti nucleolus of 
% game v using the GLPK solver.
% 
% glpk_AntiPreNucl                          - Computes the anti pre-nucleolus 
% using the GLPK solver.
% 
% glpk_AntiPreNucl_llp                      - Computes the anti pre-nucleolus 
% using the GLPK solver.
% 
% glpk_exact_game                           - Computes the exact game from v 
% using the GLPK solver.
% 
% glpk_kernel                               - Computes a kernel point using 
% the GLPK solver. 
% 
% glpk_modiclus                             - Computes the modiclus of game 
% v using glpkmex.
% 
% glpk_nucl                                 - Computes the nucleolus using the 
% GLPK solver.
% 
% glpk_nucl_llp                             - Computes the nucleolus using the 
% GLPK solver.
% 
% glpk_prekernel                            - Computes a prekernel point using 
% the GLPK solver. 
% 
% glpk_prenucl                              - Computes the prenucleolus using 
% the GLPK solver.
% 
% glpk_prenucl_llp                          - Computes the prenucleolus using 
% the GLPK solver.
% 
% greedy_bankruptcy                         - Creates the greedy bankruptcy 
% game.
% 
% gurobi_AntiNucl                           - Computes the anti nucleolus of 
% game v using the GUROBI solver.
% 
% gurobi_AntiNucl_llp                       - Computes the anti nucleolus of 
% game v using the GUROBI solver.
% 
% gurobi_AntiPreNucl                        - Computes the anti prenucleolus 
% using the GUROBI solver.
% 
% gurobi_AntiPreNucl_llp                    - Computes the anti prenucleolus 
% using the GUROBI solver.
% 
% gurobi_AssignmentGame                     - Creates an assignment game using 
% the GUROBI solver.
% 
% gurobi_exact_game                         - Computes the exact game from v 
% using the GUROBI solver.
% 
% gurobi_kernel                             - Computes a kernel point using 
% the GUROBI solver. 
% 
% gurobi_modiclus                           - Computes the modiclus of game 
% v using the GUROBI.
% 
% gurobi_nucl                               - Computes the nucleolus using the 
% GUROBI solver.
% 
% gurobi_nucl_llp                           - Computes the nucleolus using the 
% GUROBI solver.
% 
% gurobi_prekernel                          - Computes a prekernel point using 
% the GUROBI solver. 
% 
% gurobi_prenucl                            - Computes the prenucleolus using 
% the GUROBI solver.
% 
% gurobi_prenucl_llp                        - Computes the prenucleolus using 
% the GUROBI solver.
% 
% harsanyi_dividends                        - Determines the the unanimity coordinates.
% 
% holler                                    - Computes the Holler index.
% 
% homogeneous_representationQ               - Checks if the weighted majority 
% game possesses a homogeneous representation.
% 
% hsl_prekernel                             - Computes a prekernel point using 
% HSL solvers. 
% 
% hypergraphQ                               - Checks whether the system is a 
% hypergraph communication situation.
% 
% interest_game                             - Computes from an interest problem 
% the corresponding game.
% 
% ipopt_kernel                              - Computes a kernel point using 
% the IPOPT solver. 
% 
% ipopt_prekernel                           - Computes a prekernel point using 
% the IPOPT solver.
% 
% ireffq                                    - Checks if a payoff satisfies IR 
% as well as the Eff property.
% 
% jury_game                                 - Computes from a quota and the 
% number of jurors a simple game.
% 
% k_Converse_RGP_Q                          - Checks if an imputation satisfies 
% the k-CRGP.
% 
% k_Reconfirmation_propertyQ                - Checks the k-RCP.
% 
% k_Reduced_game_propertyQ                  - Checks the k-RGP.
% 
% k_StrConverse_RGP_Q                       - Checks the strong k-CRGP. 
% 
% k_anticover                               - Determines from the Tu-game the 
% corresponding anti k-game.
% 
% k_concaveQ                                - Checks k-concavity of the Tu-game.
% 
% k_convexQ                                 - Checks k-convexity of the Tu-game.
% 
% k_cover                                   - Determines from the Tu-game the 
% corresponding k-game.
% 
% kernelQ                                   - Checks if an imputation is a kernel 
% point.
% 
% lin_prekernel                             - Computes a prekernel point using 
% optimization toolbox.
% 
% linear_basis                              - Determines the linear basis of 
% the n-person TU game space.
% 
% lowersetQ                                 - Checks the existence of the lower 
% set. 
% 
% market_game                               - Determines from two disjoint sets 
% a market game.
% 
% mcst_game                                 - Computes from a cost matrix the 
% corresponding mcst game.
% 
% mediation_game                            - Assigns its outside option to 
% a coalition without player k (employer), the other players are the employees.
% 
% mex_coalitions                            - Computes the set of coalitions 
% with maximum excesses
% 
% minNoBlockPayoff                          - Computes the minimum no blocking 
% payoff from game v.
% 
% minimal_winning                           - Computes the minimal winning coalitions.
% 
% modiclusQ                                 - Verifies whether the set of induced 
% coalitions is a bi-balanced collection.
% 
% monotone_gameQ                            - Checks monotonicity of the TU 
% game.
% 
% monotonic_cover                           - Determines the monotonic cover 
% from a TU game.
% 
% msk_AntiNucl                              - Computes the anti nucleolus of 
% game v using the MOSEK solver.
% 
% msk_AntiNucl_llp                          - Computes the anti nucleolus of 
% game v using the MoSEK solver.
% 
% msk_AntiPreKernel                         - Computes from (v,x) an anti pre-kernel 
% element using MOSEKMEX.
% 
% msk_AntiPreNucl                           - Computes the anti prenucleolus 
% using the MOSEK solver.
% 
% msk_AntiPreNucl_llp                       - Computes the anti prenucleolus 
% using the MOSEK solver.
% 
% msk_AssignmentGame                        - Creates an assignment game using 
% the MOSEK solver.
% 
% msk_exact_game                            - Computes the exact game from v 
% using the MOSEK solver.
% 
% msk_kernel                                - Computes a kernel point using 
% the MOSEK solver.
% 
% msk_modiclus                              - Computes the modiclus of game 
% v using the MOSEK solver.
% 
% msk_nucl                                  - Computes the nucleolus using the 
% MOSEK solver.
% 
% msk_nucl_llp                              - Computes the nucleolus using the 
% MOSEK solver.
% 
% msk_prekernel                             - Computes a prekernel point using 
% the MOSEK solver.
% 
% msk_prenucl                               - Computes the prenucleolus using 
% the MOSEK solver.
% 
% msk_prenucl_llp                           - Computes the prenucleolus using 
% the MOSEK solver.
% 
% near_ringQ                                - Checks if a collection of coalitions 
% is a near ring. 
% 
% nucl                                      - Computes the nucleolus using optimization 
% toolbox.
% 
% nucl_llp                                  - Computes the nucleolus using optimization 
% toolbox.
% 
% oases_kernel                              - Computes a kernel point using 
% the OASES solver.
% 
% oases_prekernel                           - Computes a prekernel point using 
% the OASES solver.
% 
% ols_prekernel                             - Computes a prekernel point using 
% optimization toolbox.
% 
% potential                                 - Determines the potential of a 
% TU game (basis).
% 
% product_game                              - Computes form a vector x the corresponding 
% product game.
% 
% production_game                           - Creates an affine production game.
% 
% production_game_sq                        - Creates a quadratic production 
% game. 
% 
% profit_matrix                             - Creates the profit matrix of an 
% assignment game. 
% 
% proper_amount                             - Computes the largest amount players 
% contribute to a proper coalition.
% 
% pure_overhead                             - Creates the matrix of pure overhead 
% games.
% 
% qpBB_kernel                               - Computes a kernel point using 
% the QPBB solver.
% 
% qpc_kernel                                - Computes a kernel point using 
% the QPC solver.
% 
% qpc_prekernel                             - Computes a prekernel point using 
% the QPC solver.
% 
% qrg_prekernel                             - Computes a prekernel point using 
% qrginv instead of pinv.
% 
% quotas                                    - Determines the quotas of a game.
% 
% reasonable_outcome                        - Determines the reasonable outcome.
% 
% replicate_Shapley                         - Replicates the Shapley value for 
% a game space. 
% 
% replicate_prk                             - Replicates a pre-kernel solution 
% as a pre-kernel of a game space. 
% 
% savings_game                              - Creates a saving game from a cost 
% game.
% 
% scrb_solution                             - Computes separable costs-remaining 
% benefits allocation. 
% 
% select_starting_pt                        - Selects a starting point for the 
% pre-kernel computation.
% 
% semi_convexQ                              - Checks semi-convexity.
% 
% separable_cost_allocation                 - Computes the separable cost allocation.
% 
% separating_collectionQ                    - Verifies if a collection is separating.
% 
% shiftGame  				    - Computes from the game v the t-shift game of v.
% 
% simple_game                               - Creates a simple game.
% 
% sm_Kernel.m                               - Computes an element of the simplified 
% Kernel of a game.
% 
% sm_PreKernel  			    - Computes an element of the simplified pre-kernel of 
% game v.	    
% 
% sm_PreKernel.m                            - Computes an element of the simplified 
% Pre-kernel of a game.
% 
% sm_PreNucl                                - Computes the simplified pre-nucleolus 
% of a game.
% 
% sm_nucl                                   - Computes the simplified nucleolus 
% of a game.
% 
% smallest_amount                           - Computes the smallest amount vector.
% 
% sortsets                                  - Sorts a sub/power set w.r.t. its 
% cardinality.
% 
% streps_value                              - Determines the strong epsilon-game.
% 
% substitutes                               - Establishes which pair of players 
% are substitutes.
% 
% super_additiveQ                           - Checks the Tu-game on super additivity.
% 
% symmetricQ                                - Checks if the game v is symmetric.
% 
% totallyBalancedQ  			    - Checks whether the core of all subgames is non-empty.
% 
% unanimity_games                           - Computes the unanimity coordinates.
% 
% union_stableQ                             - Checks whether a system is union 
% stable.
% 
% uppersetQ                                 - Checks the existence of the upper 
% set.
% 
% value_matrix  			    - Computes from an assignment matrix the corresponding 
% value matrix for a permutation game.	    
% 
% vclToMatlab                               - Computes a Tu-game and the corresponding 
% unique integer representation of coalitions
% 
% veto_players                              - Determines the veto players of 
% a simple game. 
% 
% weakly_sub_additiveQ                      - Checks the Tu-game on weakly sub 
% additivity.
% 
% weakly_super_additiveQ                    - Checks the Tu-game on weakly super 
% additivity.
% 
% weightedOwen                              - Computes the weighted Owen value.
% 
% weightedShapley                           - Computes the weighted Shapley 
% value.
% 
% weightedSolidarity                        - Computes the weighted solidarity 
% value.
% 
% weighted_majority                         - Creates a weighted majority game.
% 
% winning_coalitions                        - Determines the whole set of winning 
% coalitions.
% 
% zero_monotonicQ                           - Checks zero monotonicity.
% 
% zero_normalization                        - Creates a zero normalized game.
% 
% 
% Class Objects
% 
% 
% TuACore                                   - subclass object of TuSol (anti-core 
% plot).
% 
% TuAPrn                                     - subclass object of TuSol (anti 
% pre-nucleolus from various solvers).
% 
% TuASol                                     - subclass object of TuGame (game 
% solutions).
% 
% TuAVert                                    - subclass object of TuSol (anti-core 
% vertices).
% 
% TuCons                                    - subclass object of TuSol (consistency).
% 
% TuCore                                     - subclass object of TuSol (core 
% plot).
% 
% TuGame                                   - to perform several computations 
% for retrieving and modifying game data.
% 
% TuKcons                                  - subclass object of TuSol (generalized 
% consistency).
% 
% TuKrn                                      - subclass object of TuSol (kernel 
% solutions from various solvers).
% 
% TuNuc                                     - subclass object of TuSol (nucleolus 
% from various solvers).
% 
% TuPrk                                      - subclass object of TuSol (pre-kernel 
% solutions from various solvers).
% 
% TuPrn                                      - subclass object of TuSol (pre-nucleolus 
% from various solvers).
% 
% TuProp                                    - subclass object of TuGame (game 
% properties).
% 
% TuRep                                     - subclass object of TuSol (prk 
% replication).
% 
% TuShRep                                 - subclass object of TuSol (Shapley 
% value replication).
% 
% TuSol                                      - subclass object of TuGame (game 
% solutions).
% 
% TuVal                                      - subclass object of TuGame (fairness 
% and related values).
% 
% TuVert                                     - subclass object of TuSol (core 
% vertices).
% 
% 
%% Main Functions: Parallel Computing
% 
% 
% p_ADvalue                                 - Computes the Aumann-Dreze value.
% 
% p_AllMarginalContributions                - Computes all marginal contributions 
% of a Tu-game.
% 
% p_AntiBalancedSetQ                        - Verifies whether the set of induced 
% coalitions is a anti balanced collection.
% 
% p_AntiB0_balancedCollectionQ              - Checks the reversal of weighted 
% Kohlberg's criterion.
% 
% p_AntiReduced_game_propertyQ  	    - Checks whether an imputation x satisfies 
% the anti-reduced game property.
% 
% p_Anti_Converse_DGP_Q  		    - Checks whether an imputation x satisfies the 
% anti-converse derived game property.
% 
% p_Anti_Derived_game_propertyQ  	    - Checks whether an imputation x satisfies 
% a modified anti-derived game property.
% 
% p_Anti_ModPreKernel  			    - Computes from (v,x) a modified pre-kernel element.
% 
% p_Anti_ModPrekernelQ  		    - Checks whether the imputation x is a modified 
% anti-pre-kernel element of the TU-game v.
% 
% p_Anti_PModPreKernel  		    - Computes from (v,x) a proper modified anti-pre-kernel 
% element.
% 
% p_Anti_PModPrekernelQ  		    - Checks whether the imputation x is a proper 
% modified anti-pre-kernel element of the TU-game v.
% 
% p_Anti_PreKernel                          - Computes an anti-pre-kernel element.
% 
% p_Anti_PrekernelQ                         - Checks if an imputation is an 
% anti prekernel point.
% 
% p_Anti_PropModPreKernel  		    - Computes from (v,x) a proper modified anti-pre-kernel 
% element.
% 
% p_B0_balancedCollectionQ                  - Checking weak Kohlberg's criterion.
% 
% p_BestCoalitions                          - Computes  the set of most effective 
% coalitions.
% 
% p_COV_propertyQ  			    - Verifies if the payoff x satisfies the covariance 
% with strategic equivalence property w.r.t. (v,m,t).
% 
% p_CddExactGame                            - Computes the exact game from v 
% (cddmex).
% 
% p_CddTotallyBalancedQ  		    - Checks whether the core of all subgames is 
% non-empty (cddmex).
% 
% p_CoalitionSolidarity                     - Determines the coalition solidarity 
% value.
% 
% p_Converse_DGP_Q  			    - Checks whether an imputation x satisfies the converse 
% derived game property.
% 
% p_Converse_RGP_Q                          - Checks if an imputation satisfies 
% the CRGP.
% 
% p_DM_AntiReduced_game  		    - Computes from (v,x) all anti-reduced games 
% on S at x of game v.
% 
% p_DM_Anti_Derived_game  		    - Computes from (v,x) a modified Davis-Maschler 
% anti-reduced game vS on S at x for game v.
% 
% p_DM_Derived_game  			    - Computes from (v,x) a modified Davis-Maschler 
% reduced game vS on S at x for game v.
% 
% p_DM_Reduced_game                         - Computes all Davis-Maschler reduced 
% games.
% 
% p_DecomposeGame                           - Computes the unique decomposition 
% of a TU-game.
% 
% p_Derived_game_propertyQ  		    - Checks whether an imputation x satisfies 
% a modifed derived game property.
% 
% p_DualCover  				    - The maximum characteristic values from the primal or 
% dual game.
% 
% p_DualFloor  				    - The minimum characteristic values from the primal or 
% dual game.
% 
% p_ECCoverGame  			    - Computes from (v,x) an excess comparability cover 
% of game v.
% 
% p_ECFloorGame  			    - Computes from (v,x) an excess comparability floor 
% of game v.
% 
% p_EC_DGP_Q  				    - Checks whether the solution x satisfies excess comparability 
% for each derived game.
% 
% p_EC_RGP_Q  				    - Checks whether the solution x satisfies excess comparability 
% for each reduced game.
% 
% p_EC_propertyQ  			    - Checks whether the solution x satisfies excess comparability.
% 
% p_Gap                                     - Determines the gap function.
% 
% p_HMS_AntiReduced_game  		    - Computes from (v,x) all Hart/Mas-Colell anti-reduced 
% games on S at x of game v.
% 
% p_HMS_Anti_Derived_game  		    - Computes from (v,x,S) a modified Hart-Mas-Colell 
% anti-reduced game vS on S at x for game v.
% 
% p_HMS_Derived_game  			    - Computes from (v,x,S) a modified Hart-Mas-Colell 
% reduced game vS on S at x for game v.
% 
% p_HMS_ImputSavingReducedGame              - Computes from (v,x) all Hart/Mas-Colell 
% ISR games.
% 
% p_HMS_Reduced_game                        - Creates all Hart/Mas-Colell reduced 
% games. 
% 
% p_ISRG_propertyQ                          - Checks whether an imputation x 
% satisfies the ISR game property.
% 
% p_ImputSavingReducedGame                  - Computes from (v,x) all imputation 
% saving reduced games.
% 
% p_Kernel                                  - Computes a kernel point using 
% the optimization toolbox.
% 
% p_LS_Nucl                                 - Computes the least square nucleolus 
% of a game.
% 
% p_LS_PreNucl                              - Computes the least square pre-nucleolus 
% of a game.
% 
% p_LedcoconsQ  			    - Checks whether an imputation x satisfies large excess 
% difference converse consistency. 
% 
% p_Ledcons_propertyQ  			    - Checks whether an imputation x satisfies the 
% ledcons property.
% 
% p_ModHoller  				    - Computes the modified Holler index from the set of 
% winning coalitions.
% 
% p_ModPreKernel  			    - Computes from (v,x) a modified pre-kernel element.
% 
% p_ModPrekernelQ  			    - Checks whether the imputation x is a modified pre-kernel 
% element.
% 
% p_MyersonValue                            - Computes the Myerson value of 
% a Tu game.
% 
% p_NullPlayer_propertyQ                    - Verifies if x satisfies the null 
% player property.
% 
% p_OwenValue                               - Computes the Owen value.
% 
% p_PModPreKernel  			    - Computes from (v,x) a proper modified pre-kernel 
% element.
% 
% p_PModPrekernelQ  			    - Checks whether the imputation x is a proper modified 
% pre-kernel element.
% 
% p_PermutationGame                         - Computes from an assignment matrix 
% the permutation game.
% 
% p_PositionValue                           - Computes the position value.
% 
% p_PreKernel                               - Computes a pre-kernel element.
% 
% p_PrekernelQ                              - Checks if an imputation is a pre-kernel 
% point.
% 
% p_PropModPreKernel  			    - Computes from (v,x) a proper modified pre-kernel 
% element.
% 
% p_REAS_propertyQ  			    - Checks if the vector x satisfies the reasonableness 
% on both sides.
% 
% p_REC_propertyQ  			    - Checks whether the solution x satisfies reverse 
% excess comparability.
% 
% p_Reconfirmation_propertyQ                - Checks the RCP.
% 
% p_RedGame                                 - Creates a Davis-Maschler reduced 
% game.
% 
% p_Reduced_game_propertyQ                  - Checks the RGP.
% 
% p_SD_ShapleyValue  			    - Computes the surplus division Shapley value.
% 
% p_SedcoconsQ  			    - Checks whether an imputation x satisfies small excess 
% difference converse consistency.
% 
% p_Sedcons_propertyQ  			    - Checks whether an imputation x satisfies the 
% sedcons property.
% 
% p_ShapleyQ                                - Checks if the imputation x is 
% a Shapley value of game v.
% 
% p_ShapleyValue                            - Computes the Shapley value (potential).
% 
% p_ShapleyValueLB                          - Computes the Shapley value from 
% the linear basis.
% 
% p_ShapleyValueM                           - Computes the Shapley value while 
% relying on all marginal contributions.
% 
% p_ShapleyValueML                          - Computes the Shapley value using 
% the multi-linear extension.
% 
% p_SolidarityShapleyValue                  - Determines the solidarity Shapley 
% value. 
% 
% p_SolidarityValue                         - Determines the solidarity value. 
% 
% p_StrConverse_DGP_Q  			    - Checks whether an imputation x satisfies the 
% strong converse derived game property.
% 
% p_StrConverse_RGP_Q  			    - Checks whether an imputation x satisfies the 
% strong CRGP.
% 
% p_StrLedcoconsQ  			    - Checks whether an imputation x satisfies satisfies 
% strong large excess difference converse consistency.
% 
% p_StrSedcoconsQ  			    - Checks whether an imputation x satisfies satisfies 
% strong small excess difference converse consistency.
% 
% p_SubSets                                 - Creates all subsets of super set.
% 
% p_TauValue                                - Computes the Tau value.
% 
% p_airport_profit                          - Computes from a cost and benefit 
% vector the associated surplus game.
% 
% p_assignment_game                         - Creates  an assignment game.
% 
% p_average_convexQ                         - Checks on average convexity.
% 
% p_balancedSetQ                            - Verifies whether the set of induced 
% coalitions is a balanced collection. 
% 
% p_banzhaf                                 - Computes  the Banzhaf value.
% 
% p_basis_coordinates                       - Determines the basis coordinates 
% of a Tu game.
% 
% p_basis_game                              - Determines bases games.
% 
% p_cls_kernel                              - Computes a kernel point using 
% the CLS solver.
% 
% p_clp_kernel                              - Computes a kernel point using 
% the CLP solver.
% 
% p_coeff_linearbasis                       - Determines the coefficients (dividends) 
% of a linear basis from a TU game.
% 
% p_convex_gameQ                            - Checks on convexity.
% 
% p_coreQ                                   - Checks the non-emptiness of the 
% core.
% 
% p_cplex_AssignmentGame                    - Creates an assignment game using 
% the CPLEX solver.
% 
% p_cplex_exact_game                        - Computes the exact game from v 
% using the CPLEX solver.
% 
% p_cplex_kernel                            - Computes a kernel point using 
% the CPLEX solver.
% 
% p_cplex_prekernel                         - Computes a prekernel point using 
% the CPLEX solver.
% 
% p_cvx_kernel                              - Computes a kernel point using 
% the CVX solver. 
% 
% p_cvx_prekernel                           - Computes a prekernel point using 
% the CVX solver. 
% 
% p_equal_treatmentQ                        - Checks if a vector x satisfies 
% ETP.
% 
% p_exact_game                              - Computes the exact game from v 
% using Matlab's Optimization toolbox.
% 
% p_excess                                  - Computes the excesses.
% 
% p_game_basis                              - Computes a game basis of the n-person 
% TU-game space.
% 
% p_game_space                              - Computes the game space which 
% replicates a payoff as a pre-kernel element.
% 
% p_game_space_red                          - Computes the game space which 
% replicates a payoff as a pre-kernel element.
% 
% p_genUnionStable                          - Creates a union stable system.
% 
% p_getgame                                 - Creates a Tu-game from the unanimity 
% coordinates. 
% 
% p_glpk_exact_game                         - Computes the exact game from v 
% using the GLPK solver.
% 
% p_glpk_kernel                             - Computes a kernel point using 
% the GLPK solver. 
% 
% p_glpk_prekernel                          - Computes a prekernel point using 
% the GLPK solver. 
% 
% p_gurobi_AssignmentGame                   - Creates an assignment game using 
% the GUROBI solver.
% 
% p_gurobi_exact_game                       - Computes the exact game from v 
% using the GUROBI solver.
% 
% p_gurobi_kernel                           - Computes a kernel point using 
% the GUROBI solver. 
% 
% p_gurobi_prekernel                        - Computes a prekernel point using 
% the GUROBI solver. 
% 
% p_harsanyi_dividends                      - Determines the the unanimity coordinates.
% 
% p_holler                                  - Computes the Holler index.
% 
% p_homogeneous_representationQ             - Checks if the weighted majority 
% game possesses a homogeneous representation.
% 
% p_hsl_prekernel                           - Computes a prekernel point using 
% HSL solvers. 
% 
% p_ipopt_kernel                            - Computes a kernel point using 
% the IPOPT solver.
% 
% p_ipopt_prekernel                         - Computes a prekernel point using 
% the IPOPT solver.
% 
% p_k_Converse_RGP_Q                        - Checks if an imputation satisfies 
% the k-CRGP.
% 
% p_k_Reconfirmation_propertyQ              - Checks the k-RCP.
% 
% p_k_Reduced_game_propertyQ                - Checks the k-RGP.
% 
% p_k_StrConverse_RGP_Q                     - Checks the strong k-CRGP. 
% 
% p_k_convexQ                               - Checks k-convexity of the Tu-game.
% 
% p_k_cover                                 - Determines from the Tu-game the 
% corresponding k-game.
% 
% p_lin_prekernel                           - Computes a prekernel point using 
% optimization toolbox.
% 
% p_linear_basis                            - Determines the linear basis of 
% the n-person TU game space.
% 
% p_mcst_game                               - Computes from a cost matrix the 
% corresponding mcst game.
% 
% p_minimal_winning                         - Computes the minimal winning coalitions.
% 
% p_monotone_gameQ                          - Checks monotonicity of the Tu-game.
% 
% p_msk_AssignmentGame                      - Creates an assignment game using 
% the MOSEK solver.
% 
% p_msk_exact_game                          - Computes the exact game from v 
% using the MOSEK solver.
% 
% p_msk_kernel                              - Computes a kernel point using 
% the MOSEK solver.
% 
% p_msk_prekernel                           - Computes a prekernel point using 
% the MOSEK solver.
% 
% p_oases_kernel                            - Computes a kernel point using 
% the OASES solver.
% 
% p_oases_prekernel                         - Computes a prekernel point using 
% the OASES solver.
% 
% p_ols_prekernel                           - Computes a prekernel point using 
% optimization toolbox.
% 
% p_potential                               - Determines the potential of a 
% TU game (basis).
% 
% p_pure_overhead                           - Creates the matrix of pure overhead 
% games.
% 
% p_qpBB_kernel                             - Computes a kernel point using 
% the QPBB solver.
% 
% p_qpc_kernel                              - Computes a kernel point using 
% the QPC solver.
% 
% p_qpc_prekernel                           - Computes a prekernel point using 
% the QPC solver.
% 
% p_qrg_prekernel                           - Computes a prekernel point using 
% qrginv instead of pinv.
% 
% p_reasonable_outcome                      - Determines the reasonable outcome.
% 
% p_replicate_Shapley                       - Replicates the Shapley value for 
% a game space. 
% 
% p_replicate_prk                           - Replicates a pre-kernel solution 
% as a pre-kernel of a game space. 
% 
% p_select_starting_pt                      - Selects a starting point for the 
% pre-kernel computation.
% 
% p_semi_convexQ                            - Checks semi-convexity.
% 
% p_sub_additiveQ                           - Checks the Tu-game on sub additivity.
% 
% p_substitutes                             - Establishes which pair of players 
% are substitutes.
% 
% p_super_additiveQ                         - Checks the Tu-game on super additivity.
% 
% p_totallyBalancedQ  			    - checks whether the core of all subgames is non-empty.
% 
% p_unanimity_games                         - Computes the unanimity coordinates.
% 
% p_union_stableQ                           - Checks whether a system is union 
% stable.
% 
% p_weightedOwen                            - Computes the weighted Owen value.
% 
% p_weightedShapley                         - Computes the weighted Shapley 
% value.
% 
% p_winning_coalitions                      - Computes from a pre-defined set 
% of minimal winning coalitions the whole set of winning coalitions.
% 
% p_zero_monotonicQ                         - Checks zero monotonicity.
% 
% 
% Class Objects
% 
% 
% p_TuCons                                  - subclass object of p_TuSol (consistency).
% 
% p_TuKcons                                 - subclass object of p_TuSol (generalized 
% consistency).
% 
% p_TuKrn                                   - subclass object of p_TuSol (kernel 
% solutions from various solvers).
% 
% p_TuPrk                                   - subclass object of p_TuSol (pre-kernel 
% solutions from various solvers).
% 
% p_TuProp                                  - subclass object of TuGame (game 
% properties).
% 
% p_TuRep                                   - subclass object of p_TuSol (prk 
% replication).
% 
% p_TuShRep                                 - subclass object of p_TuSol (Shapley 
% value replication).
% 
% p_TuSol                                   - subclass object of TuGame (game 
% solutions).
% 
% p_TuVal                                   - subclass object of TuGame (fairness 
% and related values).
% 
% 
%% Tools: Sed File
% 
% 
% sed_core                                  - Converts cdd file format into 
% Matlab format.
##### SOURCE END #####
--></body></html>